<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Common Lisp OGR API reference</title><link rel="stylesheet" type="text/css" href="index.css"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></head><body><div id="header"><table cellspacing="0" cellpadding="0" width="100%"><tr><td valign="center">
		  
	      <b> OGR wrapper for Lisp</b></td><td valign="center" align="right"><b>API documentation</b></td></tr></table></div><div class="main"><div id="sp-about-packages"><p><i>About cl-ogr:</i><div class="indent">no documentation string found</div></p></div><h3>Other functions in cl-ogr</h3><a name="cl-ogr__fun__data-source"></a><div class="sp-lambda-list"><b>Function data-source</b> (object)</div><div class="sp-definition"><div class="sp-definition-body"><p style="color: red; font-weight: bold">
	  No documentation string.  Possibly unimplemented or incomplete.
	</p></div></div><br><a name="cl-ogr__fun__delete-layer"></a><div class="sp-lambda-list"><b>Function delete-layer</b> (ds ilayer)</div><div class="sp-definition"><div class="sp-definition-body"><p style="color: red; font-weight: bold">
	  No documentation string.  Possibly unimplemented or incomplete.
	</p></div></div><br><a name="cl-ogr__fun__get-layer"></a><div class="sp-lambda-list"><b>Function get-layer</b> (ds idx)</div><div class="sp-definition"><div class="sp-definition-body"><p style="color: red; font-weight: bold">
	  No documentation string.  Possibly unimplemented or incomplete.
	</p></div></div><br><a name="cl-ogr__fun__get-layer-by-name"></a><div class="sp-lambda-list"><b>Function get-layer-by-name</b> (ds name)</div><div class="sp-definition"><div class="sp-definition-body"><p style="color: red; font-weight: bold">
	  No documentation string.  Possibly unimplemented or incomplete.
	</p></div></div><br><a name="cl-ogr__fun__get-layer-count"></a><div class="sp-lambda-list"><b>Function get-layer-count</b> (ds)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent"></div></div></div><br><a name="cl-ogr__fun__get-name"></a><div class="sp-lambda-list"><b>Function get-name</b> (ds)</div><div class="sp-definition"><div class="sp-definition-body"><p style="color: red; font-weight: bold">
	  No documentation string.  Possibly unimplemented or incomplete.
	</p></div></div><br><a name="cl-ogr__fun__ogr-build-polygon-from-edges"></a><div class="sp-lambda-list"><b>Function ogr-build-polygon-from-edges</b> (hlines bbesteffort bautoclose dftolerance peerr)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">an handle to the new geometry, a polygon.</div><div class="sph3">Details:</div><div class="indent">Build a ring from a bunch of arcs.<br><br> handle to an OGRGeometryCollection (or
 OGRMultiLineString) containing the line string geometries to be built into rings.<br><br> not yet implemented???. indicates if the ring should be close when first and last points of the ring are the same. tolerance into which two arcs are considered close enough to be joined. OGRERR_NONE on success, or OGRERR_FAILURE on failure.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-deregister-driver"></a><div class="sp-lambda-list"><b>Function ogr-deregister-driver</b> (hdriver)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Remove the passed driver from the list of registered drivers.<br><br>
 This function is the same as the C++ method
 OGRSFDriverRegistrar::DeregisterDriver().<br><br> handle to the driver to deregister.<br><br> Since: GDAL 1.8.0</div></div></div><br><a name="cl-ogr__fun__ogr-ds-copy-layer"></a><div class="sp-lambda-list"><b>Function ogr-ds-copy-layer</b> (hds hsrclayer psznewname papszoptions)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">an handle to the layer, or NULL if an error occurs.</div><div class="sph3">Details:</div><div class="indent">Duplicate an existing layer.<br><br>
 This function creates a new layer, duplicate the field definitions of
 the source layer and then duplicate each features of the source
 layer. The papszOptions argument can be used to control driver
 specific creation options. These options are normally documented in
 the format specific documentation. The source layer may come from
 another dataset.<br><br>
 This function is the same as the C++ method OGRDataSource::CopyLayer<br><br> handle to the data source where to create the new layer handle to the source layer. the name of the layer to create. a StringList of name=value options. Options are driver specific.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-ds-create-layer"></a><div class="sp-lambda-list"><b>Function ogr-ds-create-layer</b> (hds pszname hspatialref etype papszoptions)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">NULL is returned on failure, or a new OGRLayer handle on success.</div><div class="sph3">Details:</div><div class="indent">This function attempts to create a new layer on the data source with
 the indicated name, coordinate system, geometry type.<br><br>
 The papszOptions argument can be used to control driver specific
 creation options. These options are normally documented in the format
 specific documentation.<br><br>
 This function is the same as the C++ method
 OGRDataSource::CreateLayer().<br><br>
Parameters:	hDS 	The dataset handle.
	pszName 	the name for the new layer. This should ideally not match any existing layer on the datasource.
	hSpatialRef 	handle to the coordinate system to use for the new layer, or NULL if no coordinate system is available.
	eType 	the geometry type for the layer. Use wkbUnknown if there are no constraints on the types geometry to be written.
	papszOptions 	a StringList of name=value options. Options are driver specific, and driver information can be found at the following url: http://www.gdal.org/ogr/ogr_formats.html<br><br> <br><br>
Example:
...<pre>
        OGRLayerH *hLayer;
        char     **papszOptions;<br><br>
        if( OGR_DS_TestCapability( hDS, ODsCCreateLayer ) )
        (
            ...
        )<br><br>
        papszOptions = CSLSetNameValue( papszOptions, &quot;DIM&quot;, &quot;2&quot; );
        hLayer = OGR_DS_CreateLayer( hDS, &quot;NewLayer&quot;, NULL, wkbUnknown,
                                     papszOptions );
        CSLDestroy( papszOptions );<br><br>
        if( hLayer == NULL )
        (
            ...
        )</pre></div></div></div><br><a name="cl-ogr__fun__ogr-ds-delete-layer"></a><div class="sp-lambda-list"><b>Function ogr-ds-delete-layer</b> (hds ilayer)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">:NONE on success, or :UNSUPPORTED_OPERATION if deleting layers is not supported for this datasource.</div><div class="sph3">Details:</div><div class="indent">Delete the indicated layer from the datasource.<br><br>
 If this method is supported the ODsCDeleteLayer capability will test
 TRUE on the OGRDataSource.<br><br>
 This method is the same as the C++ method
 OGRDataSource::DeleteLayer().<br><br> handle to the datasource the index of the layer to delete.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-ds-destroy"></a><div class="sp-lambda-list"><b>Function ogr-ds-destroy</b> (hdatasource)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Closes opened datasource and releases allocated resources.<br><br>
 This method is the same as the C++ method OGRDataSource::DestroyDataSource().<br><br> handle to allocated datasource object.</div></div></div><br><a name="cl-ogr__fun__ogr-ds-execute-sql"></a><div class="sp-lambda-list"><b>Function ogr-ds-execute-sql</b> (hds pszsqlcommand hspatialfilter pszdialect)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">an handle to a OGRLayer containing the results of the query. Deallocate with OGR_DS_ReleaseResultSet().</div><div class="sph3">Details:</div><div class="indent">Execute an SQL statement against the data store.<br><br>
 The result of an SQL query is either NULL for statements that are in
 error, or that have no results set, or an OGRLayer handle
 representing a results set from the query. Note that this OGRLayer is
 in addition to the layers in the data store and must be destroyed
 with OGR_DS_ReleaseResultSet() before the data source is
 closed (destroyed).<br><br>
 For more information on the SQL dialect supported internally by OGR
 review the OGR SQL document. Some drivers (ie. Oracle and PostGIS)
 pass the SQL directly through to the underlying RDBMS.<br><br>
 Starting with OGR 1.10, the SQLITE dialect can also be used.<br><br>
 This function is the same as the C++ method
 OGRDataSource::ExecuteSQL();<br><br> handle to the data source on which the SQL query is executed. the SQL statement to execute. handle to a geometry which represents a spatial filter. Can be NULL. allows control of the statement dialect. If set
 to NULL, the OGR SQL engine will be used, except for RDBMS drivers
 that will use their dedicated SQL engine, unless OGRSQL is
 explicitely passed as the dialect. Starting with OGR 1.10, the SQLITE dialect can also be used.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-ds-get-driver"></a><div class="sp-lambda-list"><b>Function ogr-ds-get-driver</b> (hds)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">NULL if driver info is not available, or pointer to a driver owned by the OGRSFDriverManager.</div><div class="sph3">Details:</div><div class="indent">Returns the driver that the dataset was opened with.<br><br>
 This method is the same as the C++ method OGRDataSource::GetDriver()<br><br> handle to the datasource<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-ds-get-layer"></a><div class="sp-lambda-list"><b>Function ogr-ds-get-layer</b> (hds i)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">an handle to the layer, or NULL if iLayer is out of range or an error occurs.</div><div class="sph3">Details:</div><div class="indent">Fetch a layer by index.<br><br>
 The returned layer remains owned by the OGRDataSource and should not
 be deleted by the application.<br><br>
 This function is the same as the C++ method
 OGRDataSource::GetLayer().<br><br> handle to the data source from which to get the layer. a layer number between 0 and OGR_DS_GetLayerCount()-1.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-ds-get-layer-by-name"></a><div class="sp-lambda-list"><b>Function ogr-ds-get-layer-by-name</b> (hds pszlayername)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">an handle to the layer, or NULL if the layer is not found or an error occurs.</div><div class="sph3">Details:</div><div class="indent">Fetch a layer by name.<br><br>
 The returned layer remains owned by the OGRDataSource and should not
 be deleted by the application.<br><br>
 This function is the same as the C++ method OGRDataSource::GetLayerByName().<br><br> handle to the data source from which to get the layer.<br><br> Layer the layer name of the layer to fetch.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-ds-get-layer-count"></a><div class="sp-lambda-list"><b>Function ogr-ds-get-layer-count</b> (ds)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">layer count.</div><div class="sph3">Details:</div><div class="indent">Get the number of layers in this data source.<br><br>
 This function is the same as the C++ method
 OGRDataSource::GetLayerCount().<br><br> handle to the data source from which to get the number of layers.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-ds-get-name"></a><div class="sp-lambda-list"><b>Function ogr-ds-get-name</b> (hds)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">pointer to an internal name string which should not be modified or freed by the caller.</div><div class="sph3">Details:</div><div class="indent">Returns the name of the data source.<br><br>
 This string should be sufficient to open the data source if passed to
 the same OGRSFDriver that this data source was opened with, but it
 need not be exactly the same string that was used to open the data
 source. Normally this is a filename.<br><br>
 This function is the same as the C++ method OGRDataSource::GetName().<br><br> handle to the data source to get the name from.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-ds-release-result-set"></a><div class="sp-lambda-list"><b>Function ogr-ds-release-result-set</b> (hds hlayer)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Release results of OGR_DS_ExecuteSQL().<br><br>
 This function should only be used to deallocate OGRLayers resulting
 from an OGR_DS_ExecuteSQL() call on the same OGRDataSource. Failure
 to deallocate a results set before destroying the OGRDataSource may
 cause errors.<br><br>
 This function is the same as the C++ method
 OGRDataSource::ReleaseResultSet().<br><br> an handle to the data source on which was executed an SQL query. handle to the result of a previous OGR_DS_ExecuteSQL() call.</div></div></div><br><a name="cl-ogr__fun__ogr-ds-sync-to-disk"></a><div class="sp-lambda-list"><b>Function ogr-ds-sync-to-disk</b> (hds)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">:NONE if no error occurs (even if nothing is done) or an error code.</div><div class="sph3">Details:</div><div class="indent">Flush pending changes to disk.<br><br>
 This call is intended to force the datasource to flush any pending
 writes to disk, and leave the disk file in a consistent state. It
 would not normally have any effect on read-only datasources.<br><br>
 Some data sources do not implement this method, and will still return
 OGRERR_NONE. An error is only returned if an error occurs while
 attempting to flush to disk.<br><br>
 The default implementation of this method just calls the SyncToDisk()
 method on each of the layers. Conceptionally, calling SyncToDisk() on
 a datasource should include any work that might be accomplished by
 calling SyncToDisk() on layers in that data source.<br><br>
 In any event, you should always close any opened datasource with
 OGR_DS_Destroy() that will ensure all data is correctly flushed.<br><br>
 This method is the same as the C++ method OGRDataSource::SyncToDisk()<br><br> handle to the data source<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-ds-test-capability"></a><div class="sp-lambda-list"><b>Function ogr-ds-test-capability</b> (hds pszcapability)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">TRUE if capability available otherwise FALSE.</div><div class="sph3">Details:</div><div class="indent">Test if capability is available.<br><br>
 One of the following data source capability names can be passed into
 this function, and a TRUE or FALSE value will be returned indicating
 whether or not the capability is available for this object.<br><br>
 ODsCCreateLayer: True if this datasource can create new layers.<br><br>
 ODsCDeleteLayer: True if this datasource can delete existing layers.<br><br>
 ODsCCreateGeomFieldAfterCreateLayer: True if the layers of this
 datasource support CreateGeomField() just after layer creation.<br><br>
 The #define macro forms of the capability names should be used in
 preference to the strings themselves to avoid mispelling.<br><br>
 This function is the same as the C++ method
 OGRDataSource::TestCapability().<br><br> handle to the data source against which to test the capability. the capability to test.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-f-clone"></a><div class="sp-lambda-list"><b>Function ogr-f-clone</b> (hfeat)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">an handle to the new feature, exactly matching this feature.</div><div class="sph3">Details:</div><div class="indent">Duplicate feature.<br><br>
 The newly created feature is owned by the caller, and will have it's
 own reference to the OGRFeatureDefn.<br><br>
 This function is the same as the C++ method OGRFeature::Clone().<br><br> handle to the feature to clone.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-f-create"></a><div class="sp-lambda-list"><b>Function ogr-f-create</b> (hdefn)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">an handle to the new feature object with null fields and no geometry.</div><div class="sph3">Details:</div><div class="indent">Feature factory.<br><br>
 Note that the OGRFeature will increment the reference count of it's
 defining OGRFeatureDefn. Destruction of the OGRFeatureDefn before
 destruction of all OGRFeatures that depend on it is likely to result
 in a crash.<br><br>
 This function is the same as the C++ method OGRFeature::OGRFeature().<br><br> handle to the feature class (layer) definition to which the feature will adhere.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-f-destroy"></a><div class="sp-lambda-list"><b>Function ogr-f-destroy</b> (hfeat)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Destroy feature.<br><br>
 The feature is deleted, but within the context of the GDAL/OGR
 heap. This is necessary when higher level applications use GDAL/OGR
 from a DLL and they want to delete a feature created within the
 DLL. If the delete is done in the calling application the memory will
 be freed onto the application heap which is inappropriate.<br><br>
 This function is the same as the C++ method OGRFeature::DestroyFeature().<br><br> handle to the feature to destroy.</div></div></div><br><a name="cl-ogr__fun__ogr-f-dump-readable"></a><div class="sp-lambda-list"><b>Function ogr-f-dump-readable</b> (hfeat fpout)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Dump this feature in a human readable form.<br><br>
 This dumps the attributes, and geometry; however, it doesn't
 definition information (other than field types and names), nor does
 it report the geometry spatial reference system.<br><br>
 This function is the same as the C++ method
 OGRFeature::DumpReadable().<br><br> handle to the feature to dump. the stream to write to, such as strout.</div></div></div><br><a name="cl-ogr__fun__ogr-f-equal"></a><div class="sp-lambda-list"><b>Function ogr-f-equal</b> (hfeat hotherfeat)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">TRUE if they are equal, otherwise FALSE.</div><div class="sph3">Details:</div><div class="indent">Test if two features are the same.<br><br>
 Two features are considered equal if the share them (handle equality)
 same OGRFeatureDefn, have the same field values, and the same
 geometry (as tested by OGR_G_Equal()) as well as the same feature id.<br><br>
 This function is the same as the C++ method OGRFeature::Equal().<br><br> handle to one of the feature. handle to the other feature to test this one against.<br><br></div></div></div><br><a name="cl-ogr__fun__ogr-f-get-defn-ref"></a><div class="sp-lambda-list"><b>Function ogr-f-get-defn-ref</b> (hfeat)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">an handle to the feature definition object on which feature depends.</div><div class="sph3">Details:</div><div class="indent">Fetch feature definition.<br><br>
 This function is the same as the C++ method OGRFeature::GetDefnRef().<br><br> handle to the feature to get the feature definition from.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-f-get-field-as-binary"></a><div class="sp-lambda-list"><b>Function ogr-f-get-field-as-binary</b> (hfeat ifield pnbytes)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">the field value. This list is internal, and should not be modified, or freed. Its lifetime may be very brief.</div><div class="sph3">Details:</div><div class="indent">Fetch field value as binary.<br><br>
 Currently this method only works for OFTBinary fields.<br><br>
 This function is the same as the C++ method OGRFeature::GetFieldAsBinary().<br><br> handle to the feature that owned the field. the field to fetch, from 0 to GetFieldCount()-1. location to place count of bytes returned.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-f-get-field-as-date-time"></a><div class="sp-lambda-list"><b>Function ogr-f-get-field-as-date-time</b> (hfeat ifield pnyear pnmonth pnday pnhour pnminute pnsecond pntzflag)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">TRUE on success or FALSE on failure.</div><div class="sph3">Details:</div><div class="indent">Fetch field value as date and time.<br><br>
 Currently this method only works for OFTDate, OFTTime and OFTDateTime fields.<br><br>
 This function is the same as the C++ method OGRFeature::GetFieldAsDateTime().<br><br> handle to the feature that owned the field. the field to fetch, from 0 to GetFieldCount()-1. (including century) (1-12) (1-31) (0-23) (0-59) (0-59) (0=unknown, 1=localtime, 100=GMT, see data model for details)<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-f-get-field-as-double"></a><div class="sp-lambda-list"><b>Function ogr-f-get-field-as-double</b> (hfeat ifield)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">the field value.</div><div class="sph3">Details:</div><div class="indent">Fetch field value as a double.<br><br>
 OFTString features will be translated using atof(). OFTInteger fields
 will be cast to double. Other field types, or errors will result in a
 return value of zero.<br><br>
 This function is the same as the C++ method
 OGRFeature::GetFieldAsDouble().<br><br> handle to the feature that owned the field. the field to fetch, from 0 to GetFieldCount()-1.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-f-get-field-as-double-list"></a><div class="sp-lambda-list"><b>Function ogr-f-get-field-as-double-list</b> (hfeat ifield pncount)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">the field value. This list is internal, and should not be
 modified, or freed. Its lifetime may be very brief. If *pnCount is zero on return the returned pointer may be NULL or non-NULL.</div><div class="sph3">Details:</div><div class="indent">Fetch field value as a list of doubles.<br><br>
 Currently this function only works for OFTRealList fields.<br><br>
 This function is the same as the C++ method OGRFeature::GetFieldAsDoubleList().<br><br> handle to the feature that owned the field. the field to fetch, from 0 to GetFieldCount()-1. an integer to put the list count (number of doubles) into.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-f-get-field-as-integer"></a><div class="sp-lambda-list"><b>Function ogr-f-get-field-as-integer</b> (hfeat ifield)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">the field value.</div><div class="sph3">Details:</div><div class="indent">Fetch field value as integer.<br><br>
 OFTString features will be translated using atoi(). OFTReal fields
 will be cast to integer. Other field types, or errors will result in
 a return value of zero.<br><br>
 This function is the same as the C++ method OGRFeature::GetFieldAsInteger().<br><br> handle to the feature that owned the field. the field to fetch, from 0 to GetFieldCount()-1.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-f-get-field-as-integer-list"></a><div class="sp-lambda-list"><b>Function ogr-f-get-field-as-integer-list</b> (hfeat ifield pncount)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">the field value. This list is internal, and should not be
 modified, or freed. Its lifetime may be very brief. If *pnCount is zero on return the returned pointer may be NULL or non-NULL.</div><div class="sph3">Details:</div><div class="indent">Fetch field value as a list of integers.<br><br>
 Currently this function only works for OFTIntegerList fields.<br><br>
 This function is the same as the C++ method
 OGRFeature::GetFieldAsIntegerList().<br><br> handle to the feature that owned the field. the field to fetch, from 0 to GetFieldCount()-1. an integer to put the list count (number of integers) into.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-f-get-field-as-string"></a><div class="sp-lambda-list"><b>Function ogr-f-get-field-as-string</b> (hfeat ifield)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">the field value. This string is internal, and should not be modified, or freed. Its lifetime may be very brief.</div><div class="sph3">Details:</div><div class="indent">Fetch field value as a string.<br><br>
 OFTReal and OFTInteger fields will be translated to string using
 sprintf(), but not necessarily using the established formatting
 rules. Other field types, or errors will result in a return value of
 zero.<br><br>
 This function is the same as the C++ method
 OGRFeature::GetFieldAsString().<br><br> handle to the feature that owned the field. the field to fetch, from 0 to GetFieldCount()-1.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-f-get-field-as-string-list"></a><div class="sp-lambda-list"><b>Function ogr-f-get-field-as-string-list</b> (hfeat ifield)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">the field value. This list is internal, and should not be modified, or freed. Its lifetime may be very brief.</div><div class="sph3">Details:</div><div class="indent">Fetch field value as a list of strings.<br><br>
 Currently this method only works for OFTStringList fields.<br><br>
 The returned list is terminated by a NULL pointer. The number of
 elements can also be calculated using CSLCount().<br><br>
 This function is the same as the C++ method OGRFeature::GetFieldAsStringList().<br><br> handle to the feature that owned the field. the field to fetch, from 0 to GetFieldCount()-1.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-f-get-field-count"></a><div class="sp-lambda-list"><b>Function ogr-f-get-field-count</b> (hfeat)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">count of fields.</div><div class="sph3">Details:</div><div class="indent">Fetch number of fields on this feature This will always be the same
 as the field count for the OGRFeatureDefn.<br><br>
 This function is the same as the C++ method
 OGRFeature::GetFieldCount().<br><br> handle to the feature to get the fields count from.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-f-get-field-defn-ref"></a><div class="sp-lambda-list"><b>Function ogr-f-get-field-defn-ref</b> (hfeat i)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">an handle to the field definition (from the
 OGRFeatureDefn). This is an internal reference, and should not be deleted or modified.</div><div class="sph3">Details:</div><div class="indent">Fetch definition for this field.<br><br>
 This function is the same as the C++ method OGRFeature::GetFieldDefnRef().<br><br> handle to the feature on which the field is found. the field to fetch, from 0 to GetFieldCount()-1.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-f-get-field-index"></a><div class="sp-lambda-list"><b>Function ogr-f-get-field-index</b> (hfeat pszname)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">the field index, or -1 if no matching field is found.</div><div class="sph3">Details:</div><div class="indent">Fetch the field index given field name.<br><br>
 This is a cover for the OGRFeatureDefn::GetFieldIndex() method.<br><br>
 This function is the same as the C++ method OGRFeature::GetFieldIndex().<br><br> handle to the feature on which the field is found. the name of the field to search for.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-f-get-geom-field-count"></a><div class="sp-lambda-list"><b>Function ogr-f-get-geom-field-count</b> (hfeat)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">count of geometry fields.</div><div class="sph3">Details:</div><div class="indent">Fetch number of geometry fields on this feature This will always be
 the same as the geometry field count for the OGRFeatureDefn.<br><br>
 This function is the same as the C++ method
 OGRFeature::GetGeomFieldCount().<br><br> handle to the feature to get the geometry fields count from.<br><br> <br><br> Since: GDAL 2.0</div></div></div><br><a name="cl-ogr__fun__ogr-f-get-geom-field-defn-ref"></a><div class="sp-lambda-list"><b>Function ogr-f-get-geom-field-defn-ref</b> (hfeat i)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">an handle to the field definition (from the
 OGRFeatureDefn). This is an internal reference, and should not be deleted or modified.</div><div class="sph3">Details:</div><div class="indent">Fetch definition for this geometry field.<br><br>
 This function is the same as the C++ method OGRFeature::GetGeomFieldDefnRef().<br><br> handle to the feature on which the field is found. the field to fetch, from 0 to GetGeomFieldCount()-1.<br><br> <br><br>Since: GDAL 2.0</div></div></div><br><a name="cl-ogr__fun__ogr-f-get-geom-field-index"></a><div class="sp-lambda-list"><b>Function ogr-f-get-geom-field-index</b> (hfeat pszname)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">the geometry field index, or -1 if no matching geometry field is found.</div><div class="sph3">Details:</div><div class="indent">Fetch the geometry field index given geometry field name.<br><br>
 This is a cover for the OGRFeatureDefn::GetGeomFieldIndex() method.<br><br>
 This function is the same as the C++ method
 OGRFeature::GetGeomFieldIndex().<br><br> handle to the feature on which the geometry field is found. the name of the geometry field to search for.<br><br> <br><br>Since: GDAL 2.0</div></div></div><br><a name="cl-ogr__fun__ogr-f-get-geom-field-ref"></a><div class="sp-lambda-list"><b>Function ogr-f-get-geom-field-ref</b> (hfeat ifield)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">an handle to internal feature geometry. This object should not be modified.</div><div class="sph3">Details:</div><div class="indent">Fetch an handle to feature geometry.<br><br>
 This function is the same as the C++ method OGRFeature::GetGeomFieldRef().<br><br> handle to the feature to get geometry from. geometry field to get.<br><br> <br><br>Since: GDAL 2.0</div></div></div><br><a name="cl-ogr__fun__ogr-f-get-geometry-ref"></a><div class="sp-lambda-list"><b>Function ogr-f-get-geometry-ref</b> (hfeat)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">an handle to internal feature geometry. This object should not be modified.</div><div class="sph3">Details:</div><div class="indent">Fetch an handle to feature geometry.<br><br>
 This function is the same as the C++ method
 OGRFeature::GetGeometryRef().<br><br> handle to the feature to get geometry from.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-f-get-raw-field-ref"></a><div class="sp-lambda-list"><b>Function ogr-f-get-raw-field-ref</b> (hfeat ifield)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">the returned handle is to an internal data structure, and should not be freed, or modified.</div><div class="sph3">Details:</div><div class="indent">Fetch an handle to the internal field value given the index.<br><br>
 This function is the same as the C++ method
 OGRFeature::GetRawFieldRef().<br><br> handle to the feature on which field is found. the field to fetch, from 0 to GetFieldCount()-1.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-f-get-style-string"></a><div class="sp-lambda-list"><b>Function ogr-f-get-style-string</b> (hfeat)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">a reference to a representation in string format, or NULL if there isn't one.</div><div class="sph3">Details:</div><div class="indent">Fetch style string for this feature.<br><br>
 Set the OGR Feature Style Specification for details on the format of
 this string, and ogr_featurestyle.h for services available to parse
 it.<br><br>
 This function is the same as the C++ method OGRFeature::GetStyleString().<br><br> handle to the feature to get the style from.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-f-is-field-set"></a><div class="sp-lambda-list"><b>Function ogr-f-is-field-set</b> (hfeat ifield)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">TRUE if the field has been set, otherwise false.</div><div class="sph3">Details:</div><div class="indent">Test if a field has ever been assigned a value or not.<br><br>
 This function is the same as the C++ method OGRFeature::IsFieldSet().<br><br> handle to the feature on which the field is. the field to test.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-f-set-fid"></a><div class="sp-lambda-list"><b>Function ogr-f-set-fid</b> (hfeat nfid)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">On success OGRERR_NONE, or on failure some other value.</div><div class="sph3">Details:</div><div class="indent">Set the feature identifier.<br><br>
 For specific types of features this operation may fail on illegal
 features ids. Generally it always succeeds. Feature ids should be
 greater than or equal to zero, with the exception of OGRNullFID (-1)
 indicating that the feature id is unknown.<br><br>
 This function is the same as the C++ method OGRFeature::SetFID().<br><br> handle to the feature to set the feature id to. the new feature identifier value to assign.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-f-set-field-binary"></a><div class="sp-lambda-list"><b>Function ogr-f-set-field-binary</b> (hfeat ifield nbytes pabydata)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Set field to binary data.<br><br>
 This function currently on has an effect of OFTBinary fields.<br><br>
 This function is the same as the C++ method OGRFeature::SetField().<br><br> handle to the feature that owned the field. the field to set, from 0 to GetFieldCount()-1. the number of bytes in pabyData array. the data to apply.</div></div></div><br><a name="cl-ogr__fun__ogr-f-set-field-date-time"></a><div class="sp-lambda-list"><b>Function ogr-f-set-field-date-time</b> (hfeat ifield nyear nmonth nday nhour nminute nsecond ntzflag)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Set field to datetime.<br><br>
 This method currently only has an effect for OFTDate, OFTTime and
 OFTDateTime fields.<br><br> handle to the feature that owned the field. the field to set, from 0 to GetFieldCount()-1. (including century) (1-12) (1-31) (0-23) (0-59) (0-59) (0=unknown, 1=localtime, 100=GMT, see data model for details)</div></div></div><br><a name="cl-ogr__fun__ogr-f-set-field-double"></a><div class="sp-lambda-list"><b>Function ogr-f-set-field-double</b> (hfeat ifield dfvalue)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Set field to double value.<br><br>
 OFTInteger and OFTReal fields will be set directly. OFTString fields
 will be assigned a string representation of the value, but not
 necessarily taking into account formatting constraints on this
 field. Other field types may be unaffected.<br><br>
 This function is the same as the C++ method OGRFeature::SetField().<br><br> handle to the feature that owned the field. the field to fetch, from 0 to GetFieldCount()-1. the value to assign.</div></div></div><br><a name="cl-ogr__fun__ogr-f-set-field-double-list"></a><div class="sp-lambda-list"><b>Function ogr-f-set-field-double-list</b> (hfeat ifield ncount padfvalues)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Set field to list of doubles value.<br><br>
 This function currently on has an effect of OFTRealList fields.<br><br>
 This function is the same as the C++ method OGRFeature::SetField().<br><br> handle to the feature that owned the field. the field to set, from 0 to GetFieldCount()-1. the number of values in the list being assigned. the values to assign.</div></div></div><br><a name="cl-ogr__fun__ogr-f-set-field-integer"></a><div class="sp-lambda-list"><b>Function ogr-f-set-field-integer</b> (hfeat ifield nvalue)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Set field to integer value.<br><br>
 OFTInteger and OFTReal fields will be set directly. OFTString fields
 will be assigned a string representation of the value, but not
 necessarily taking into account formatting constraints on this
 field. Other field types may be unaffected.<br><br>
 This function is the same as the C++ method OGRFeature::SetField().<br><br> handle to the feature that owned the field. the field to fetch, from 0 to GetFieldCount()-1. the value to assign.</div></div></div><br><a name="cl-ogr__fun__ogr-f-set-field-integer-list"></a><div class="sp-lambda-list"><b>Function ogr-f-set-field-integer-list</b> (hfeat ifield ncount panvalues)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Set field to list of integers value.<br><br>
 This function currently on has an effect of OFTIntegerList fields.<br><br>
 This function is the same as the C++ method OGRFeature::SetField().<br><br> handle to the feature that owned the field. the field to set, from 0 to GetFieldCount()-1. the number of values in the list being assigned. the values to assign.</div></div></div><br><a name="cl-ogr__fun__ogr-f-set-field-raw"></a><div class="sp-lambda-list"><b>Function ogr-f-set-field-raw</b> (hfeat ifield psvalue)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Set field.<br><br>
 The passed value OGRField must be of exactly the same type as the
 target field, or an application crash may occur. The passed value is
 copied, and will not be affected. It remains the responsibility of
 the caller.<br><br>
 This function is the same as the C++ method OGRFeature::SetField().<br><br> handle to the feature that owned the field. the field to fetch, from 0 to GetFieldCount()-1. handle on the value to assign.</div></div></div><br><a name="cl-ogr__fun__ogr-f-set-field-string"></a><div class="sp-lambda-list"><b>Function ogr-f-set-field-string</b> (hfeat ifield pszvalue)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Set field to string value.<br><br>
 OFTInteger fields will be set based on an atoi() conversion of the
 string. OFTReal fields will be set based on an atof() conversion of
 the string. Other field types may be unaffected.<br><br>
 This function is the same as the C++ method OGRFeature::SetField().<br><br> handle to the feature that owned the field. the field to fetch, from 0 to GetFieldCount()-1. the value to assign.</div></div></div><br><a name="cl-ogr__fun__ogr-f-set-field-string-list"></a><div class="sp-lambda-list"><b>Function ogr-f-set-field-string-list</b> (hfeat ifield papszvalues)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Set field to list of strings value.<br><br>
This function currently on has an effect of OFTStringList fields.<br><br>
 This function is the same as the C++ method OGRFeature::SetField().<br><br> handle to the feature that owned the field. the field to set, from 0 to GetFieldCount()-1. the values to assign.</div></div></div><br><a name="cl-ogr__fun__ogr-f-set-from"></a><div class="sp-lambda-list"><b>Function ogr-f-set-from</b> (hfeat hotherfeat bforgiving)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">OGRERR_NONE if the operation succeeds, even if some values are not transferred, otherwise an error code.</div><div class="sph3">Details:</div><div class="indent">Set one feature from another.<br><br>
 Overwrite the contents of this feature from the geometry and
 attributes of another. The hOtherFeature does not need to have the
 same OGRFeatureDefn. Field values are copied by corresponding field
 names. Field types do not have to exactly match. OGR_F_SetField*()
 function conversion rules will be applied as needed.<br><br>
 This function is the same as the C++ method OGRFeature::SetFrom().<br><br> handle to the feature to set to. handle to the feature from which geometry, and field values will be copied. TRUE if the operation should continue despite lacking output fields matching some of the source fields.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-f-set-from-with-map"></a><div class="sp-lambda-list"><b>Function ogr-f-set-from-with-map</b> (hfeat hotherfeat bforgiving panmap)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">OGRERR_NONE if the operation succeeds, even if some values are not transferred, otherwise an error code.</div><div class="sph3">Details:</div><div class="indent">Set one feature from another.<br><br>
 Overwrite the contents of this feature from the geometry and
 attributes of another. The hOtherFeature does not need to have the
 same OGRFeatureDefn. Field values are copied according to the
 provided indices map. Field types do not have to exactly
 match. OGR_F_SetField*() function conversion rules will be applied as
 needed. This is more efficient than OGR_F_SetFrom() in that this
 doesn't lookup the fields by their names. Particularly useful when
 the field names don't match.<br><br>
 This function is the same as the C++ method OGRFeature::SetFrom().<br><br> handle to the feature to set to. handle to the feature from which geometry, and field values will be copied. Array of the indices of the destination feature's
 fields stored at the corresponding index of the source feature's
 fields. A value of -1 should be used to ignore the source's
 field. The array should not be NULL and be as long as the number of fields in the source feature. TRUE if the operation should continue despite lacking output fields matching some of the source fields.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-f-set-geom-field"></a><div class="sp-lambda-list"><b>Function ogr-f-set-geom-field</b> (hfeat ifield hgeom)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">:NONE if successful, or :UNSUPPORTED_GEOMETRY_TYPE
 if the geometry type is illegal for the OGRFeatureDefn (checking not yet implemented).</div><div class="sph3">Details:</div><div class="indent">Set feature geometry of a specified geometry field.<br><br>
 This function updates the features geometry, and operate exactly as
 SetGeometryDirectly(), except that this function does not assume
 ownership of the passed geometry, but instead makes a copy of it.<br><br>
This function is the same as the C++ OGRFeature::SetGeomField().<br><br> handle to the feature on which new geometry is applied to. geometry field to set. handle to the new geometry to apply to feature.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-f-set-geom-field-directly"></a><div class="sp-lambda-list"><b>Function ogr-f-set-geom-field-directly</b> (hfeat ifield hgeom)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">:NONE if successful, or :FAILURE if the index is
 invalid, or :UNSUPPORTED_GEOMETRY_TYPE if the geometry type is illegal for the OGRFeatureDefn (checking not yet implemented).</div><div class="sph3">Details:</div><div class="indent">Set feature geometry of a specified geometry field.<br><br>
 This function updates the features geometry, and operate exactly as
 SetGeomField(), except that this function assumes ownership of the
 passed geometry.<br><br>
 This function is the same as the C++ method OGRFeature::SetGeomFieldDirectly.<br><br> handle to the feature on which to apply the geometry. geometry field to set. handle to the new geometry to apply to feature.<br><br> <br><br>Since: GDAL 2.0</div></div></div><br><a name="cl-ogr__fun__ogr-f-set-geometry"></a><div class="sp-lambda-list"><b>Function ogr-f-set-geometry</b> (hfeat hgeom)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">:NONE if successful, or :UNSUPPORTED_GEOMETRY_TYPE if the
 geometry type is illegal for the OGRFeatureDefn (checking not yet implemented).</div><div class="sph3">Details:</div><div class="indent">Set feature geometry.<br><br>
 This function updates the features geometry, and operate exactly as
 SetGeometryDirectly(), except that this function does not assume
 ownership of the passed geometry, but instead makes a copy of it.<br><br>
 This function is the same as the C++ OGRFeature::SetGeometry().<br><br> handle to the feature on which new geometry is applied to. handle to the new geometry to apply to feature.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-f-set-geometry-directly"></a><div class="sp-lambda-list"><b>Function ogr-f-set-geometry-directly</b> (hfeat hgeom)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">OGRERR_NONE if successful, or OGR_UNSUPPORTED_GEOMETRY_TYPE
 if the geometry type is illegal for the OGRFeatureDefn (checking not yet implemented).</div><div class="sph3">Details:</div><div class="indent">Set feature geometry.<br><br>
 This function updates the features geometry, and operate exactly as
 SetGeometry(), except that this function assumes ownership of the
 passed geometry.<br><br>
 This function is the same as the C++ method
 OGRFeature::SetGeometryDirectly.<br><br> handle to the feature on which to apply the geometry. handle to the new geometry to apply to feature.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-f-set-style-string"></a><div class="sp-lambda-list"><b>Function ogr-f-set-style-string</b> (hfeat pszstyle)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Set feature style string. This method operate exactly as
 OGR_F_SetStyleStringDirectly() except that it does not assume
 ownership of the passed string, but instead makes a copy of it.<br><br>
 This function is the same as the C++ method OGRFeature::SetStyleString().<br><br> handle to the feature to set style to. the style string to apply to this feature, cannot be NULL.</div></div></div><br><a name="cl-ogr__fun__ogr-f-set-style-string-directly"></a><div class="sp-lambda-list"><b>Function ogr-f-set-style-string-directly</b> (hfeat pszstyle)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Set feature style string. This method operate exactly as
 OGR_F_SetStyleString() except that it assumes ownership of the passed
 string.<br><br>
 This function is the same as the C++ method
 OGRFeature::SetStyleStringDirectly().<br><br> handle to the feature to set style to. the style string to apply to this feature, cannot be NULL.</div></div></div><br><a name="cl-ogr__fun__ogr-f-steal-geometry"></a><div class="sp-lambda-list"><b>Function ogr-f-steal-geometry</b> (hfeat)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">the pointer to the geometry.</div><div class="sph3">Details:</div><div class="indent">Take away ownership of geometry.<br><br>
 Fetch the geometry from this feature, and clear the reference to the
 geometry on the feature. This is a mechanism for the application to
 take over ownship of the geometry from the feature without
 copying. Sort of an inverse to OGR_FSetGeometryDirectly().<br><br>
 After this call the OGRFeature will have a NULL geometry.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-f-unset-field"></a><div class="sp-lambda-list"><b>Function ogr-f-unset-field</b> (hfeat ifield)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Clear a field, marking it as unset.<br><br>
 This function is the same as the C++ method OGRFeature::UnsetField().<br><br> handle to the feature on which the field is. the field to unset.</div></div></div><br><a name="cl-ogr__fun__ogr-fd-add-field-defn"></a><div class="sp-lambda-list"><b>Function ogr-fd-add-field-defn</b> (hdefn hnewfield)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Add a new field definition to the passed feature definition.<br><br>
 To add a new field definition to a layer definition, do not use this
 function directly, but use OGR_L_CreateField() instead.<br><br>
 This function should only be called while there are no OGRFeature
 objects in existance based on this OGRFeatureDefn. The OGRFieldDefn
 passed in is copied, and remains the responsibility of the caller.<br><br>
 This function is the same as the C++ method
 OGRFeatureDefn::AddFieldDefn().<br><br> handle to the feature definition to add the field definition to.<br><br> handle to the new field definition.</div></div></div><br><a name="cl-ogr__fun__ogr-fd-add-geom-field-defn"></a><div class="sp-lambda-list"><b>Function ogr-fd-add-geom-field-defn</b> (hdefn hnewgeomfield)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Add a new field definition to the passed feature definition.<br><br>
 To add a new field definition to a layer definition, do not use this
 function directly, but use OGR_L_CreateGeomField() instead.<br><br>
 This function should only be called while there are no OGRFeature
 objects in existance based on this OGRFeatureDefn. The
 OGRGeomFieldDefn passed in is copied, and remains the responsibility
 of the caller.<br><br>
 This function is the same as the C++ method
 OGRFeatureDefn::AddGeomFieldDefn().<br><br> handle to the feature definition to add the geometry field definition to.<br><br> handle to the new field definition.<br><br> Since: GDAL 2.0</div></div></div><br><a name="cl-ogr__fun__ogr-fd-create"></a><div class="sp-lambda-list"><b>Function ogr-fd-create</b> (pszname)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">handle to the newly created feature definition.</div><div class="sph3">Details:</div><div class="indent">Create a new feature definition object to hold the field definitions.<br><br>
 The OGRFeatureDefn maintains a reference count, but this starts at
 zero, and should normally be incremented by the owner.<br><br>
 This function is the same as the C++ method
 OGRFeatureDefn::OGRFeatureDefn().<br><br> the name to be assigned to this layer/class. It does not need to be unique.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-fd-delete-field-defn"></a><div class="sp-lambda-list"><b>Function ogr-fd-delete-field-defn</b> (hdefn ifield)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">OGRERR_NONE in case of success.</div><div class="sph3">Details:</div><div class="indent">Delete an existing field definition.<br><br>
 To delete an existing field definition from a layer definition, do
 not use this function directly, but use OGR_L_DeleteField() instead.<br><br>
 This method should only be called while there are no OGRFeature
 objects in existance based on this OGRFeatureDefn.<br><br>
 This method is the same as the C++ method
 OGRFeatureDefn::DeleteFieldDefn().<br><br> handle to the feature definition. the index of the field defintion.<br><br> <br><br>Since: OGR 1.9.0</div></div></div><br><a name="cl-ogr__fun__ogr-fd-delete-geom-field-defn"></a><div class="sp-lambda-list"><b>Function ogr-fd-delete-geom-field-defn</b> (hdefn igeomfield)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">OGRERR_NONE in case of success.</div><div class="sph3">Details:</div><div class="indent">Delete an existing geometry field definition.<br><br>
 To delete an existing geometry field definition from a layer
 definition, do not use this function directly, but use
 OGR_L_DeleteGeomField() instead (*not implemented yet*)<br><br>
 This method should only be called while there are no OGRFeature
 objects in existance based on this OGRFeatureDefn.<br><br>
 This method is the same as the C++ method
 OGRFeatureDefn::DeleteGeomFieldDefn().<br><br> handle to the feature definition. the index of the geometry field defintion.<br><br> <br><br> Since: GDAL 2.0</div></div></div><br><a name="cl-ogr__fun__ogr-fd-dereference"></a><div class="sp-lambda-list"><b>Function ogr-fd-dereference</b> (hdefn)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">the updated reference count.</div><div class="sph3">Details:</div><div class="indent">Decrements the reference count by one.<br><br>
 This function is the same as the C++ method
 OGRFeatureDefn::Dereference().<br><br> handle to the feature definition on witch OGRFeature are based on.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-fd-destroy"></a><div class="sp-lambda-list"><b>Function ogr-fd-destroy</b> (hdefn)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Destroy a feature definition object and release all memory associated
 with it.<br><br>
 This function is the same as the C++ method
 OGRFeatureDefn::~OGRFeatureDefn().<br><br> handle to the feature definition to be destroyed.</div></div></div><br><a name="cl-ogr__fun__ogr-fd-get-field-count"></a><div class="sp-lambda-list"><b>Function ogr-fd-get-field-count</b> (hdefn)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">count of fields.</div><div class="sph3">Details:</div><div class="indent">Fetch number of fields on the passed feature definition.<br><br>
 This function is the same as the C++ OGRFeatureDefn::GetFieldCount().<br><br> handle to the feature definition to get the fields count from.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-fd-get-field-defn"></a><div class="sp-lambda-list"><b>Function ogr-fd-get-field-defn</b> (hdefn ifield)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">ogr-field-defn-h an handle to an internal field definition
 object or NULL if invalid index. This object should not be modified or freed by the application.</div><div class="sph3">Details:</div><div class="indent">Fetch field definition of the passed feature definition.<br><br>
 This function is the same as the C++ method
 OGRFeatureDefn::GetFieldDefn().<br><br>
 Starting with GDAL 1.7.0, this method will also issue an error if the
 index is not valid.<br><br> handle to the feature definition to get the field definition from. the field to fetch, between 0 and GetFieldCount()-1.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-fd-get-field-index"></a><div class="sp-lambda-list"><b>Function ogr-fd-get-field-index</b> (hdefn pszfieldname)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">the field index, or -1 if no match found.</div><div class="sph3">Details:</div><div class="indent">Find field by name.<br><br>
 The field index of the first field matching the passed field
 name (case insensitively) is returned.<br><br>
 This function is the same as the C++ method
 OGRFeatureDefn::GetFieldIndex.<br><br> handle to the feature definition to get field index from. the field name to search for.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-fd-get-geom-field-count"></a><div class="sp-lambda-list"><b>Function ogr-fd-get-geom-field-count</b> (hdefn)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">count of geometry fields.</div><div class="sph3">Details:</div><div class="indent">Fetch number of geometry fields on the passed feature definition.<br><br>
 This function is the same as the C++ OGRFeatureDefn::GetGeomFieldCount().<br><br> handle to the feature definition to get the fields count from.<br><br> <br><br> Since: GDAL 2.0</div></div></div><br><a name="cl-ogr__fun__ogr-fd-get-geom-field-defn"></a><div class="sp-lambda-list"><b>Function ogr-fd-get-geom-field-defn</b> (hdefn igeomfield)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">an handle to an internal field definition object or NULL if
 invalid index. This object should not be modified or freed by the application.</div><div class="sph3">Details:</div><div class="indent">Fetch geometry field definition of the passed feature definition.<br><br>
 This function is the same as the C++ method
 OGRFeatureDefn::GetGeomFieldDefn().<br><br> handle to the feature definition to get the field definition from. the geometry field to fetch, between 0 and GetGeomFieldCount()-1.<br><br> <br><br> Since: GDAL 2.0</div></div></div><br><a name="cl-ogr__fun__ogr-fd-get-geom-field-index"></a><div class="sp-lambda-list"><b>Function ogr-fd-get-geom-field-index</b> (hdefn pszgeomfieldname)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">the geometry field index, or -1 if no match found.</div><div class="sph3">Details:</div><div class="indent">Find geometry field by name.<br><br>
 The geometry field index of the first geometry field matching the
 passed field name (case insensitively) is returned.<br><br>
 This function is the same as the C++ method
 OGRFeatureDefn::GetGeomFieldIndex.<br><br> handle to the feature definition to get field index from. the geometry field name to search for.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-fd-get-geom-type"></a><div class="sp-lambda-list"><b>Function ogr-fd-get-geom-type</b> (hdefn)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">the base type for all geometry related to this definition.</div><div class="sph3">Details:</div><div class="indent">Fetch the geometry base type of the passed feature definition.<br><br>
 This function is the same as the C++ method
 OGRFeatureDefn::GetGeomType().<br><br>
 Starting with GDAL 2.0, this method returns
 GetGeomFieldDefn(0)-&gt;GetType().<br><br> handle to the feature definition to get the geometry type from.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-fd-get-name"></a><div class="sp-lambda-list"><b>Function ogr-fd-get-name</b> (hdefn)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">the name. This name is internal and should not be modified, or freed.</div><div class="sph3">Details:</div><div class="indent">Get name of the OGRFeatureDefn passed as an argument.<br><br>
 This function is the same as the C++ method
 OGRFeatureDefn::GetName().<br><br> handle to the feature definition to get the name from.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-fd-get-reference-count"></a><div class="sp-lambda-list"><b>Function ogr-fd-get-reference-count</b> (hdefn)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">the current reference count.</div><div class="sph3">Details:</div><div class="indent">Fetch current reference count.<br><br>
 This function is the same as the C++ method
 OGRFeatureDefn::GetReferenceCount().<br><br> handle to the feature definition on witch OGRFeature are based on.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-fd-is-geometry-ignored"></a><div class="sp-lambda-list"><b>Function ogr-fd-is-geometry-ignored</b> (hdefn)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">ignore state</div><div class="sph3">Details:</div><div class="indent">Determine whether the geometry can be omitted when fetching features.<br><br>
 This function is the same as the C++ method
 OGRFeatureDefn::IsGeometryIgnored().<br><br>
 Starting with GDAL 2.0, this method returns
 GetGeomFieldDefn(0)-&gt;IsIgnored().<br><br> handle to the feature definition on witch OGRFeature are based on.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-fd-is-same"></a><div class="sp-lambda-list"><b>Function ogr-fd-is-same</b> (hfdefn hotherfdefn)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">TRUE if the feature definition is identical to the other one.</div><div class="sph3">Details:</div><div class="indent">Test if the feature definition is identical to the other one.<br><br> handle to the feature definition on witch OGRFeature are based on. handle to the other feature definition to compare to.<br><br> <br><br> Since: OGR 2.0</div></div></div><br><a name="cl-ogr__fun__ogr-fd-is-style-ignored"></a><div class="sp-lambda-list"><b>Function ogr-fd-is-style-ignored</b> (hdefn)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">ignore state</div><div class="sph3">Details:</div><div class="indent">Determine whether the style can be omitted when fetching features.<br><br>
 This function is the same as the C++ method
 OGRFeatureDefn::IsStyleIgnored().<br><br> handle to the feature definition on which OGRFeature are based on.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-fd-reference"></a><div class="sp-lambda-list"><b>Function ogr-fd-reference</b> (hdefn)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">the updated reference count.</div><div class="sph3">Details:</div><div class="indent">Increments the reference count by one.<br><br>
 The reference count is used keep track of the number of OGRFeature
 objects referencing this definition.<br><br>
 This function is the same as the C++ method
 OGRFeatureDefn::Reference().<br><br> handle to the feature definition on witch OGRFeature are based on.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-fd-release"></a><div class="sp-lambda-list"><b>Function ogr-fd-release</b> (hdefn)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Drop a reference, and destroy if unreferenced.<br><br>
 This function is the same as the C++ method
 OGRFeatureDefn::Release().<br><br> handle to the feature definition to be released.</div></div></div><br><a name="cl-ogr__fun__ogr-fd-set-geom-type"></a><div class="sp-lambda-list"><b>Function ogr-fd-set-geom-type</b> (hdefn etype)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Assign the base geometry type for the passed layer (the same as the
 feature definition).<br><br>
 All geometry objects using this type must be of the defined type or a
 derived type. The default upon creation is wkbUnknown which allows
 for any geometry type. The geometry type should generally not be
 changed after any OGRFeatures have been created against this
 definition.<br><br>
 This function is the same as the C++ method
 OGRFeatureDefn::SetGeomType().<br><br>
 Starting with GDAL 2.0, this method calls
 GetGeomFieldDefn(0)-&gt;SetType().<br><br> handle to the layer or feature definition to set the geometry type to. the new type to assign.</div></div></div><br><a name="cl-ogr__fun__ogr-fd-set-geometry-ignored"></a><div class="sp-lambda-list"><b>Function ogr-fd-set-geometry-ignored</b> (hdefn bignore)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Set whether the geometry can be omitted when fetching features.<br><br>
 This function is the same as the C++ method
 OGRFeatureDefn::SetGeometryIgnored().<br><br>
 Starting with GDAL 2.0, this method calls
 GetGeomFieldDefn(0)-&gt;SetIgnored().<br><br> handle to the feature definition on witch OGRFeature are based on. ignore state</div></div></div><br><a name="cl-ogr__fun__ogr-fld-create"></a><div class="sp-lambda-list"><b>Function ogr-fld-create</b> (pszname etype)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">handle to the new field definition.</div><div class="sph3">Details:</div><div class="indent">Create a new field definition.<br><br>
 This function is the same as the CPP method
 OGRFieldDefn::OGRFieldDefn().<br><br> the name of the new field definition. the type of the new field definition.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-fld-destroy"></a><div class="sp-lambda-list"><b>Function ogr-fld-destroy</b> (hdefn)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Destroy a field definition.<br><br> handle to the field definition to destroy.</div></div></div><br><a name="cl-ogr__fun__ogr-fld-get-justify"></a><div class="sp-lambda-list"><b>Function ogr-fld-get-justify</b> (hdefn)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">the justification.</div><div class="sph3">Details:</div><div class="indent">Get the justification for this field.<br><br>
 This function is the same as the CPP method
 OGRFieldDefn::GetJustify().<br><br> handle to the field definition to get justification from.<br><br></div></div></div><br><a name="cl-ogr__fun__ogr-fld-get-name-ref"></a><div class="sp-lambda-list"><b>Function ogr-fld-get-name-ref</b> (hdefn)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">the name of the field definition.</div><div class="sph3">Details:</div><div class="indent">Fetch name of this field.<br><br>
 This function is the same as the CPP method
 OGRFieldDefn::GetNameRef().<br><br> handle to the field definition.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-fld-get-precision"></a><div class="sp-lambda-list"><b>Function ogr-fld-get-precision</b> (hdefn)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">the precision.</div><div class="sph3">Details:</div><div class="indent">Get the formatting precision for this field. This should normally be
 zero for fields of types other than OFTReal.<br><br>
 This function is the same as the CPP method
 OGRFieldDefn::GetPrecision().<br><br> handle to the field definition to get precision from.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-fld-get-type"></a><div class="sp-lambda-list"><b>Function ogr-fld-get-type</b> (hdefn)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">ogr-field-type field type.</div><div class="sph3">Details:</div><div class="indent">Fetch type of this field.<br><br>
 This function is the same as the CPP method OGRFieldDefn::GetType().<br><br> handle to the field definition to get type from.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-fld-get-width"></a><div class="sp-lambda-list"><b>Function ogr-fld-get-width</b> (hdefn)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">the width, zero means no specified width.</div><div class="sph3">Details:</div><div class="indent">Get the formatting width for this field.<br><br>
 This function is the same as the CPP method OGRFieldDefn::GetWidth().<br><br> handle to the field definition to get width from.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-fld-is-ignored"></a><div class="sp-lambda-list"><b>Function ogr-fld-is-ignored</b> (hdefn)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">ignore state</div><div class="sph3">Details:</div><div class="indent">Return whether this field should be omitted when fetching features.<br><br>
 This method is the same as the C++ method OGRFieldDefn::IsIgnored().<br><br> handle to the field definition<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-fld-set"></a><div class="sp-lambda-list"><b>Function ogr-fld-set</b> (hdefn psznamein etypein nwidthin nprecisionin ejustifyin)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Set defining parameters for a field in one call.<br><br>
This function is the same as the CPP method OGRFieldDefn::Set().<br><br> handle to the field definition to set to. the new name to assign. the new type (one of the OFT values like OFTInteger). the preferred formatting width. Defaults to zero indicating undefined. number of decimals places for formatting, defaults to zero indicating undefined. the formatting justification (OJLeft or OJRight), defaults to OJUndefined.</div></div></div><br><a name="cl-ogr__fun__ogr-fld-set-ignored"></a><div class="sp-lambda-list"><b>Function ogr-fld-set-ignored</b> (hdefn ignore)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Set whether this field should be omitted when fetching features.<br><br>
 This method is the same as the C++ method OGRFieldDefn::SetIgnored().<br><br> handle to the field definition ignore state</div></div></div><br><a name="cl-ogr__fun__ogr-fld-set-justify"></a><div class="sp-lambda-list"><b>Function ogr-fld-set-justify</b> (hdefn ejustify)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Set the justification for this field.<br><br>
 This function is the same as the CPP method
 OGRFieldDefn::SetJustify().<br><br> handle to the field definition to set justification to. the new justification.</div></div></div><br><a name="cl-ogr__fun__ogr-fld-set-name"></a><div class="sp-lambda-list"><b>Function ogr-fld-set-name</b> (hdefn pszname)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Reset the name of this field.<br><br>
 This function is the same as the CPP method OGRFieldDefn::SetName().<br><br> handle to the field definition to apply the new name to. the new name to apply.</div></div></div><br><a name="cl-ogr__fun__ogr-fld-set-precision"></a><div class="sp-lambda-list"><b>Function ogr-fld-set-precision</b> (hdefn nprecision)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Set the formatting precision for this field in characters.<br><br>
This should normally be zero for fields of types other than OFTReal.<br><br>
This function is the same as the CPP method OGRFieldDefn::SetPrecision().<br><br> handle to the field definition to set precision to. the new precision.</div></div></div><br><a name="cl-ogr__fun__ogr-fld-set-type"></a><div class="sp-lambda-list"><b>Function ogr-fld-set-type</b> (hdefn etype)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Set the type of this field. This should never be done to an
 OGRFieldDefn that is already part of an OGRFeatureDefn.<br><br>
 This function is the same as the CPP method OGRFieldDefn::SetType().<br><br> handle to the field definition to set type to. the new field type.</div></div></div><br><a name="cl-ogr__fun__ogr-fld-set-width"></a><div class="sp-lambda-list"><b>Function ogr-fld-set-width</b> (hdefn nnewwidth)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Set the formatting width for this field in characters.<br><br>
 This function is the same as the CPP method OGRFieldDefn::SetWidth().<br><br> handle to the field definition to set width to. the new width.</div></div></div><br><a name="cl-ogr__fun__ogr-g-add-geometry"></a><div class="sp-lambda-list"><b>Function ogr-g-add-geometry</b> (hgeom hnewsubgeom)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">OGRERR_NONE if successful, or
 OGRERR_UNSUPPORTED_GEOMETRY_TYPE if the geometry type is illegal for the type of existing geometry.</div><div class="sph3">Details:</div><div class="indent">Add a geometry to a geometry container.<br><br>
 Some subclasses of OGRGeometryCollection restrict the types of
 geometry that can be added, and may return an error. The passed
 geometry is cloned to make an internal copy.<br><br>
 There is no SFCOM analog to this method.<br><br>
 This function is the same as the CPP method
 OGRGeometryCollection::addGeometry.<br><br>
 For a polygon, hNewSubGeom must be a linearring. If the polygon is
 empty, the first added subgeometry will be the exterior ring. The
 next ones will be the interior rings.<br><br> existing geometry container.<br><br> geometry to add to the container.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-g-add-geometry-directly"></a><div class="sp-lambda-list"><b>Function ogr-g-add-geometry-directly</b> (hgeom hnewsubgeom)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">:NONE if successful, or
 :UNSUPPORTED_GEOMETRY_TYPE if the geometry type is illegal for the type of geometry container.</div><div class="sph3">Details:</div><div class="indent">Add a geometry directly to an existing geometry container.<br><br>
 Some subclasses of OGRGeometryCollection restrict the types of
 geometry that can be added, and may return an error. Ownership of the
 passed geometry is taken by the container rather than cloning as
 addGeometry() does.<br><br>
 This function is the same as the CPP method
 OGRGeometryCollection::addGeometryDirectly.<br><br>
 There is no SFCOM analog to this method.<br><br>
 For a polygon, hNewSubGeom must be a linearring. If the polygon is
 empty, the first added subgeometry will be the exterior ring. The
 next ones will be the interior rings.<br><br> existing geometry. geometry to add to the existing geometry.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-g-add-point"></a><div class="sp-lambda-list"><b>Function ogr-g-add-point</b> (hgeom dfx dfy dfz)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Add a point to a geometry (line string or point).<br><br>
 The vertex count of the line string is increased by one, and assigned
 from the passed location value.<br><br> handle to the geometry to add a point to. x coordinate of point to add. y coordinate of point to add. z coordinate of point to add.</div></div></div><br><a name="cl-ogr__fun__ogr-g-add-point-2d"></a><div class="sp-lambda-list"><b>Function ogr-g-add-point-2d</b> (hgeom dfx dfy)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Add a point to a geometry (line string or point).<br><br>
 The vertex count of the line string is increased by one, and assigned
 from the passed location value.<br><br> handle to the geometry to add a point to.<br><br> x coordinate of point to add.<br><br> y coordinate of point to add.</div></div></div><br><a name="cl-ogr__fun__ogr-g-approximate-arc-angles"></a><div class="sp-lambda-list"><b>Function ogr-g-approximate-arc-angles</b> (dfcenterx dfcentery dfz dfprimaryradius dfsecondaryradius dfrotation dfstartangle dfendangle dfmaxanglestepsizedegrees)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Stroke arc to linestring.<br><br>
Stroke an arc of a circle to a linestring based on a center point,
radius, start angle and end angle, all angles in degrees.<br><br>
If the dfMaxAngleStepSizeDegrees is zero, then a default value will be
used. This is currently 4 degrees unless the user has overridden the
value with the OGR_ARC_STEPSIZE configuration variable.<br><br>
See also:
CPLSetConfigOption()<br><br>
Parameters:	dfCenterX 	center X
	dfCenterY 	center Y
	dfZ 	center Z
	dfPrimaryRadius 	X radius of ellipse.
	dfSecondaryRadius 	Y radius of ellipse.
	dfRotation 	rotation of the ellipse clockwise.
	dfStartAngle 	angle to first point on arc (clockwise of X-positive)
	dfEndAngle 	angle to last point on arc (clockwise of X-positive)
	dfMaxAngleStepSizeDegrees 	the largest step in degrees along the arc, zero to use the default setting.<br><br>
Returns:
OGRLineString geometry representing an approximation of the arc.
Since:OGR 1.8.0</div></div></div><br><a name="cl-ogr__fun__ogr-g-area"></a><div class="sp-lambda-list"><b>Function ogr-g-area</b> (hgeom)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">the area or 0.0 for unsupported geometry types.</div><div class="sph3">Details:</div><div class="indent">Compute geometry area.<br><br>
 Computes the area for an OGRLinearRing, OGRPolygon or
 OGRMultiPolygon. Undefined for all other geometry types (returns
 zero).<br><br>
 This function utilizes the C++ get_Area() methods such as
 OGRPolygon::get_Area().<br><br> the geometry to operate on.<br><br> <br><br> Since: OGR 1.8.0</div></div></div><br><a name="cl-ogr__fun__ogr-g-assign-spatial-reference"></a><div class="sp-lambda-list"><b>Function ogr-g-assign-spatial-reference</b> (hgeom hsrs)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Assign spatial reference to this object.<br><br>
 Any existing spatial reference is replaced, but under no
 circumstances does this result in the object being reprojected. It is
 just changing the interpretation of the existing geometry. Note that
 assigning a spatial reference increments the reference count on the
 OGRSpatialReference, but does not copy it.<br><br>
 This is similar to the SFCOM IGeometry::put_SpatialReference()
 method.<br><br>
 This function is the same as the CPP method
 OGRGeometry::assignSpatialReference.<br><br> handle on the geometry to apply the new spatial reference system.<br><br> handle on the new spatial reference system to apply.</div></div></div><br><a name="cl-ogr__fun__ogr-g-boundary"></a><div class="sp-lambda-list"><b>Function ogr-g-boundary</b> (htarget)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">a handle to a newly allocated geometry now owned by the caller, or NULL on failure.</div><div class="sph3">Details:</div><div class="indent">Compute boundary.<br><br>
 A new geometry object is created and returned containing the boundary
 of the geometry on which the method is invoked.<br><br>
 This function is the same as the C++ method OGR_G_Boundary().<br><br>
 This function is built on the GEOS library, check it for the
 definition of the geometry operation. If OGR is built without the
 GEOS library, this function will always fail, issuing a
 CPLE_NotSupported error.<br><br> The Geometry to calculate the boundary of.<br><br> <br><br> Since: OGR 1.8.0</div></div></div><br><a name="cl-ogr__fun__ogr-g-buffer"></a><div class="sp-lambda-list"><b>Function ogr-g-buffer</b> (htarget dfdist nquadsegs)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">the newly created geometry, or NULL if an error occurs.</div><div class="sph3">Details:</div><div class="indent">Compute buffer of geometry.<br><br>
 Builds a new geometry containing the buffer region around the
 geometry on which it is invoked. The buffer is a polygon containing
 the region within the buffer distance of the original geometry.<br><br>
 Some buffer sections are properly described as curves, but are
 converted to approximate polygons. The nQuadSegs parameter can be
 used to control how many segements should be used to define a 90
 degree curve - a quadrant of a circle. A value of 30 is a reasonable
 default. Large values result in large numbers of vertices in the
 resulting buffer geometry while small numbers reduce the accuracy of
 the result.<br><br>
 This function is the same as the C++ method OGRGeometry::Buffer().<br><br>
 This function is built on the GEOS library, check it for the
 definition of the geometry operation. If OGR is built without the
 GEOS library, this function will always fail, issuing a
 CPLE_NotSupported error.<br><br> the geometry. the buffer distance to be applied. the number of segments used to approximate a 90 degree (quadrant) of curvature.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-g-centroid"></a><div class="sp-lambda-list"><b>Function ogr-g-centroid</b> (hgeom hcentroidpoint)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">:NONE on success or :FAILURE on error.</div><div class="sph3">Details:</div><div class="indent">Compute the geometry centroid.<br><br>
 The centroid location is applied to the passed in OGRPoint
 object. The centroid is not necessarily within the geometry.<br><br>
 This method relates to the SFCOM ISurface::get_Centroid() method
 however the current implementation based on GEOS can operate on other
 geometry types such as multipoint, linestring, geometrycollection
 such as multipolygons. OGC SF SQL 1.1 defines the operation for
 surfaces (polygons). SQL/MM-Part 3 defines the operation for surfaces
 and multisurfaces (multipolygons).<br><br>
 This function is the same as the C++ method OGRGeometry::Centroid().<br><br>
 This function is built on the GEOS library, check it for the
 definition of the geometry operation. If OGR is built without the
 GEOS library, this function will always fail, issuing a
 CPLE_NotSupported error.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-g-close-rings"></a><div class="sp-lambda-list"><b>Function ogr-g-close-rings</b> (hgeom)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Force rings to be closed.<br><br>
 If this geometry, or any contained geometries has polygon rings that
 are not closed, they will be closed by adding the starting point at
 the end.<br><br> handle to the geometry.</div></div></div><br><a name="cl-ogr__fun__ogr-g-contains"></a><div class="sp-lambda-list"><b>Function ogr-g-contains</b> (hthis hother)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">TRUE if hThis contains hOther geometry, otherwise FALSE.</div><div class="sph3">Details:</div><div class="indent">Test for containment.<br><br>
 Tests if this geometry contains the other geometry.<br><br>
 This function is the same as the C++ method OGRGeometry::Contains().<br><br>
 This function is built on the GEOS library, check it for the
 definition of the geometry operation. If OGR is built without the
 GEOS library, this function will always fail, issuing a
 CPLE_NotSupported error.<br><br> the geometry to compare.<br><br> the other geometry to compare.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-g-convex-hull"></a><div class="sp-lambda-list"><b>Function ogr-g-convex-hull</b> (htarget)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">a handle to a newly allocated geometry now owned by the caller, or NULL on failure.</div><div class="sph3">Details:</div><div class="indent">Compute convex hull.<br><br>
 A new geometry object is created and returned containing the convex
 hull of the geometry on which the method is invoked.<br><br>
 This function is the same as the C++ method OGRGeometry::ConvexHull().<br><br>
 This function is built on the GEOS library, check it for the
 definition of the geometry operation. If OGR is built without the
 GEOS library, this function will always fail, issuing a
 CPLE_NotSupported error.<br><br> The Geometry to calculate the convex hull of.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-g-create-from-gml"></a><div class="sp-lambda-list"><b>Function ogr-g-create-from-gml</b> (pszgml)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">a geometry on succes, or NULL on error.</div><div class="sph3">Details:</div><div class="indent">Create geometry from GML.<br><br>
 This method translates a fragment of GML containing only the geometry
 portion into a corresponding OGRGeometry. There are many limitations
 on the forms of GML geometries supported by this parser, but they are
 too numerous to list here.<br><br>
 The following GML2 elements are parsed : Point, LineString, Polygon,
 MultiPoint, MultiLineString, MultiPolygon, MultiGeometry.<br><br>
 (OGR &gt;= 1.8.0) The following GML3 elements are parsed : Surface,
 MultiSurface, PolygonPatch, Triangle, Rectangle, Curve, MultiCurve,
 CompositeCurve, LineStringSegment, Arc, Circle, CompositeSurface,
 OrientableSurface, Solid, Tin, TriangulatedSurface.<br><br>
 Arc and Circle elements are stroked to linestring, by using a 4
 degrees step, unless the user has overridden the value with the
 OGR_ARC_STEPSIZE configuration variable.<br><br>
 The C++ method OGRGeometryFactory::createFromGML() is the same as
 this function.<br><br> The GML fragment for the geometry.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-g-create-from-wkb"></a><div class="sp-lambda-list"><b>Function ogr-g-create-from-wkb</b> (pabydata hsrs phgeometry nbytes)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">:NONE if all goes well, otherwise any of
 :NOT_ENOUGH_DATA, :UNSUPPORTED_GEOMETRY_TYPE, or :CORRUPT_DATA may be returned.</div><div class="sph3">Details:</div><div class="indent">Create a geometry object of the appropriate type from it's well
 known binary representation.<br><br>
 Note that if nBytes is passed as zero, no checking can be done on
 whether the pabyData is sufficient. This can result in a crash if the
 input data is corrupt. This function returns no indication of the
 number of bytes from the data source actually used to represent the
 returned geometry object. Use OGR_G_WkbSize() on the returned
 geometry to establish the number of bytes it required in WKB format.<br><br>
 The OGRGeometryFactory::createFromWkb() CPP method is the same as this function.<br><br> pointer to the input BLOB data.<br><br> handle to the spatial reference to be assigned to the created geometry object. This may be NULL.<br><br> the newly created geometry object will be
 assigned to the indicated handle on return. This will be NULL in case
 of failure. If not NULL, *phGeometry should be freed with OGR_G_DestroyGeometry() after use.<br><br> the number of bytes of data available in pabyData, or -1 if it is not known, but assumed to be sufficient.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-g-create-from-wkt"></a><div class="sp-lambda-list"><b>Function ogr-g-create-from-wkt</b> (ppszdata hsrs phgeometry)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">NONE if all goes well, otherwise any of
 NOT_ENOUGH_DATA, UNSUPPORTED_GEOMETRY_TYPE, or CORRUPT_DATA may be returned.</div><div class="sph3">Details:</div><div class="indent">Create a geometry object of the appropriate type from it's well
 known text representation.<br><br>
 The OGRGeometryFactory::createFromWkt CPP method is the same as this
 function.<br><br> input zero terminated string containing well
 known text representation of the geometry to be created. The pointer is updated to point just beyond that last character consumed.<br><br> handle to the spatial reference to be assigned to the created geometry object. This may be NULL.<br><br> the newly created geometry object will be
 assigned to the indicated handle on return. This will be NULL if the
 method fails. If not NULL, *phGeometry should be freed with OGR_G_DestroyGeometry() after use.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-g-create-geometry"></a><div class="sp-lambda-list"><b>Function ogr-g-create-geometry</b> (egeometrytype)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">handle to the newly create geometry or NULL on failure. Should be freed with OGR_G_DestroyGeometry() after use.</div><div class="sph3">Details:</div><div class="indent">Create an empty geometry of desired type.<br><br>
 This is equivalent to allocating the desired geometry with new, but
 the allocation is guaranteed to take place in the context of the
 GDAL/OGR heap.<br><br>
 This function is the same as the CPP method
 OGRGeometryFactory::createGeometry.<br><br> the type code of the geometry to be created.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-g-crosses"></a><div class="sp-lambda-list"><b>Function ogr-g-crosses</b> (hthis hother)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">TRUE if they are crossing, otherwise FALSE.</div><div class="sph3">Details:</div><div class="indent">Test for crossing.<br><br>
 Tests if this geometry and the other geometry are crossing.<br><br>
 This function is the same as the C++ method OGRGeometry::Crosses().<br><br>
 This function is built on the GEOS library, check it for the
 definition of the geometry operation. If OGR is built without the
 GEOS library, this function will always fail, issuing a
 CPLE_NotSupported error.<br><br> the geometry to compare.<br><br> the other geometry to compare.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-g-difference"></a><div class="sp-lambda-list"><b>Function ogr-g-difference</b> (hthis hother)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">a new geometry representing the difference or NULL if the difference is empty or an error occurs.</div><div class="sph3">Details:</div><div class="indent">Compute difference.<br><br>
 Generates a new geometry which is the region of this geometry with
 the region of the other geometry removed.<br><br>
 This function is the same as the C++ method
 OGRGeometry::Difference().<br><br>
 This function is built on the GEOS library, check it for the
 definition of the geometry operation. If OGR is built without the
 GEOS library, this function will always fail, issuing a
 CPLE_NotSupported error.<br><br> the geometry.<br><br> the other geometry.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-g-disjoint"></a><div class="sp-lambda-list"><b>Function ogr-g-disjoint</b> (hthis hother)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">TRUE if they are disjoint, otherwise FALSE.</div><div class="sph3">Details:</div><div class="indent">Test for disjointness.<br><br>
 Tests if this geometry and the other geometry are disjoint.<br><br>
 This function is the same as the C++ method OGRGeometry::Disjoint().<br><br>
 This function is built on the GEOS library, check it for the
 definition of the geometry operation. If OGR is built without the
 GEOS library, this function will always fail, issuing a
 CPLE_NotSupported error.<br><br> the geometry to compare.<br><br> the other geometry to compare.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-g-distance"></a><div class="sp-lambda-list"><b>Function ogr-g-distance</b> (hfirst hother)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">the distance between the geometries or -1 if an error occurs.</div><div class="sph3">Details:</div><div class="indent">Compute distance between two geometries.<br><br>
 Returns the shortest distance between the two geometries.<br><br>
 This function is the same as the C++ method OGRGeometry::Distance().<br><br>
 This function is built on the GEOS library, check it for the
 definition of the geometry operation. If OGR is built without the
 GEOS library, this function will always fail, issuing a
 CPLE_NotSupported error.<br><br> the first geometry to compare against.<br><br> the other geometry to compare against.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-g-empty"></a><div class="sp-lambda-list"><b>Function ogr-g-empty</b> (hgeom)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Clear geometry information. This restores the geometry to it's
 initial state after construction, and before assignment of actual
 geometry.<br><br>
 This function relates to the SFCOM IGeometry::Empty() method.<br><br>
 This function is the same as the CPP method OGRGeometry::empty().<br><br> handle on the geometry to empty.</div></div></div><br><a name="cl-ogr__fun__ogr-g-equals"></a><div class="sp-lambda-list"><b>Function ogr-g-equals</b> (hgeom hother)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">TRUE if equivalent or FALSE otherwise.</div><div class="sph3">Details:</div><div class="indent">Returns TRUE if two geometries are equivalent.<br><br>
 This function is the same as the CPP method OGRGeometry::Equals()
 method.<br><br> handle on the first geometry.<br><br> handle on the other geometry to test against.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-g-export-to-gml"></a><div class="sp-lambda-list"><b>Function ogr-g-export-to-gml</b> (hgeometry)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">A GML fragment or NULL in case of error.</div><div class="sph3">Details:</div><div class="indent">Convert a geometry into GML format.<br><br>
 The GML geometry is expressed directly in terms of GML basic data
 types assuming the this is available in the gml namespace. The
 returned string should be freed with CPLFree() when no longer
 required.<br><br>
 This method is the same as the C++ method OGRGeometry::exportToGML().<br><br> handle to the geometry.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-g-export-to-gml-ex"></a><div class="sp-lambda-list"><b>Function ogr-g-export-to-gml-ex</b> (hgeometry papszoptions)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">A GML fragment or NULL in case of error.</div><div class="sph3">Details:</div><div class="indent">Convert a geometry into GML format.<br><br>
 The GML geometry is expressed directly in terms of GML basic data
 types assuming the this is available in the gml namespace. The
 returned string should be freed with CPLFree() when no longer
 required.<br><br>
 The supported options in OGR 1.8.0 are :<br><br>
 FORMAT=GML3. Otherwise it will default to GML 2.1.2 output.<br><br>
 GML3_LINESTRING_ELEMENT=curve. (Only valid for FORMAT=GML3) To use
 gml:Curve element for linestrings. Otherwise gml:LineString will be
 used .<br><br>
 GML3_LONGSRS=YES/NO. (Only valid for FORMAT=GML3) Default to YES. If
 YES, SRS with EPSG authority will be written with
 the &quot;urn:ogc:def:crs:EPSG::&quot; prefix. In the case, if the SRS is a
 geographic SRS without explicit AXIS order, but that the same SRS
 authority code imported with ImportFromEPSGA() should be treated as
 lat/long, then the function will take care of coordinate order
 swapping. If set to NO, SRS with EPSG authority will be written with
 the &quot;EPSG:&quot; prefix, even if they are in lat/long order.<br><br>
 GMLID=astring. If specified, a gml:id attribute will be written in
 the top-level geometry element with the provided value. Required for
 GML 3.2 compatibility.<br><br>
 This method is the same as the C++ method OGRGeometry::exportToGML().<br><br> handle to the geometry. NULL-terminated list of options.<br><br>  Since: OGR 1.8.0</div></div></div><br><a name="cl-ogr__fun__ogr-g-export-to-json"></a><div class="sp-lambda-list"><b>Function ogr-g-export-to-json</b> (hgeometry)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">A GeoJSON fragment or NULL in case of error.</div><div class="sph3">Details:</div><div class="indent">Convert a geometry into GeoJSON format.<br><br>
 The returned string should be freed with CPLFree() when no longer
 required.<br><br>
 This method is the same as the C++ method
 OGRGeometry::exportToJson().<br><br> handle to the geometry.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-g-export-to-json-ex"></a><div class="sp-lambda-list"><b>Function ogr-g-export-to-json-ex</b> (hgeometry papszoptions)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">A GeoJSON fragment or NULL in case of error.</div><div class="sph3">Details:</div><div class="indent">Convert a geometry into GeoJSON format.<br><br>
 The returned string should be freed with CPLFree() when no longer required.<br><br>
 This method is the same as the C++ method OGRGeometry::exportToJson().<br><br> handle to the geometry.<br><br> a null terminated list of options. For now,
 only COORDINATE_PRECISION=int_number where int_number is the maximum number of figures after decimal separator to write in coordinates.<br><br> <br><br> Since: OGR 1.9.0</div></div></div><br><a name="cl-ogr__fun__ogr-g-export-to-kml"></a><div class="sp-lambda-list"><b>Function ogr-g-export-to-kml</b> (hgeometry pszaltitudemode)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">A KML fragment or NULL in case of error.</div><div class="sph3">Details:</div><div class="indent">Convert a geometry into KML format.<br><br>
 The returned string should be freed with CPLFree() when no longer
 required.<br><br>
 This method is the same as the C++ method OGRGeometry::exportToKML().<br><br> handle to the geometry.<br><br> value to write in altitudeMode element, or NULL.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-g-flatten-to-2d"></a><div class="sp-lambda-list"><b>Function ogr-g-flatten-to-2d</b> (hgeom)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Convert geometry to strictly 2D. In a sense this converts all Z coordinates to 0.0.<br><br>
 This function is the same as the CPP method OGRGeometry::flattenTo2D().<br><br> handle on the geometry to convert.</div></div></div><br><a name="cl-ogr__fun__ogr-g-force-to-polygon"></a><div class="sp-lambda-list"><b>Function ogr-g-force-to-polygon</b> (hgeom)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">the converted geometry (ownership to caller).</div><div class="sph3">Details:</div><div class="indent">Convert to polygon.<br><br>
 This function is the same as the C++ method
 OGRGeometryFactory::forceToPolygon().<br><br> handle to the geometry to convert (ownership surrendered).<br><br> <br><br> Since: GDAL/OGR 1.8.0</div></div></div><br><a name="cl-ogr__fun__ogr-g-get-geometry-count"></a><div class="sp-lambda-list"><b>Function ogr-g-get-geometry-count</b> (hgeom)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">the number of elements.</div><div class="sph3">Details:</div><div class="indent">Fetch the number of elements in a geometry or number of geometries in
 container.<br><br>
 Only geometries of type wkbPolygon[25D], wkbMultiPoint[25D],
 wkbMultiLineString[25D], wkbMultiPolygon[25D] or
 wkbGeometryCollection[25D] may return a valid value. Other geometry
 types will silently return 0.<br><br>
 For a polygon, the returned number is the number of rings (exterior
 ring + interior rings).<br><br> single geometry or geometry container from which to get the number of elements.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-g-get-geometry-name"></a><div class="sp-lambda-list"><b>Function ogr-g-get-geometry-name</b> (hgeom)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">name used for this geometry type in well known text format.</div><div class="sph3">Details:</div><div class="indent">Fetch WKT name for geometry type.<br><br>
 There is no SFCOM analog to this function.<br><br>
 This function is the same as the CPP method OGRGeometry::getGeometryName().<br><br> handle on the geometry to get name from.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-g-get-geometry-ref"></a><div class="sp-lambda-list"><b>Function ogr-g-get-geometry-ref</b> (hgeom isubgeom)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">handle to the requested geometry.</div><div class="sph3">Details:</div><div class="indent">Fetch geometry from a geometry container.<br><br>
 This function returns an handle to a geometry within the
 container. The returned geometry remains owned by the container, and
 should not be modified. The handle is only valid untill the next
 change to the geometry container. Use OGR_G_Clone() to make a copy.<br><br>
 This function relates to the SFCOM
 IGeometryCollection::get_Geometry() method.<br><br>
 This function is the same as the CPP method
 OGRGeometryCollection::getGeometryRef().<br><br>
 For a polygon, OGR_G_GetGeometryRef(iSubGeom) returns the exterior
 ring if iSubGeom == 0, and the interior rings for iSubGeom &gt; 0.<br><br> handle to the geometry container from which to get a geometry from.<br><br> the index of the geometry to fetch, between 0 and getNumGeometries() - 1.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-g-get-geometry-type"></a><div class="sp-lambda-list"><b>Function ogr-g-get-geometry-type</b> (hgeom)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">the geometry type code.</div><div class="sph3">Details:</div><div class="indent">Fetch geometry type.<br><br>
 Note that the geometry type may include the 2.5D flag. To get a 2D
 flattened version of the geometry type apply the wkbFlatten() macro
 to the return result.<br><br>
 This function is the same as the CPP method
 OGRGeometry::getGeometryType().<br><br> handle on the geometry to get type from.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-g-get-point"></a><div class="sp-lambda-list"><b>Function ogr-g-get-point</b> (hgeom i pdfx pdfy pdfz)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Fetch a point in line string or a point geometry.<br><br> handle to the geometry from which to get the coordinates. the vertex to fetch, from 0 to getNumPoints()-1, zero for a point. value of x coordinate. value of y coordinate. value of z coordinate.</div></div></div><br><a name="cl-ogr__fun__ogr-g-get-point-count"></a><div class="sp-lambda-list"><b>Function ogr-g-get-point-count</b> (hgeom)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">the number of points.</div><div class="sph3">Details:</div><div class="indent">Fetch number of points from a geometry.<br><br>
 Only wkbPoint[25D] or wkbLineString[25D] may return a valid
 value. Other geometry types will silently return 0.<br><br> handle to the geometry from which to get the number of points.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-g-get-points"></a><div class="sp-lambda-list"><b>Function ogr-g-get-points</b> (hgeom pabyx nxstride pabyy nystride pabyz nzstride)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">the number of points</div><div class="sph3">Details:</div><div class="indent">Returns all points of line string.<br><br>
 This method copies all points into user arrays. The user provides the
 stride between 2 consecutives elements of the array.<br><br>
 On some CPU architectures, care must be taken so that the arrays are
 properly aligned.<br><br> handle to the geometry from which to get the coordinates.<br><br> a buffer of at least (sizeof(double) * nXStride * nPointCount) bytes, may be NULL.<br><br> the number of bytes between 2 elements of pabyX.<br><br> a buffer of at least (sizeof(double) * nYStride * nPointCount) bytes, may be NULL.<br><br> the number of bytes between 2 elements of pabyY.<br><br> a buffer of at last size (sizeof(double) * nZStride * nPointCount) bytes, may be NULL.<br><br> the number of bytes between 2 elements of pabyZ.<br><br> <br><br> Since: OGR 1.9.0</div></div></div><br><a name="cl-ogr__fun__ogr-g-get-spatial-reference"></a><div class="sp-lambda-list"><b>Function ogr-g-get-spatial-reference</b> (hgeom)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">a reference to the spatial reference geometry.</div><div class="sph3">Details:</div><div class="indent">Returns spatial reference system for geometry.<br><br>
 This function relates to the SFCOM IGeometry::get_SpatialReference()
 method.<br><br>
 This function is the same as the CPP method
 OGRGeometry::getSpatialReference().<br><br> handle on the geometry to get spatial reference from.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-g-getx"></a><div class="sp-lambda-list"><b>Function ogr-g-getx</b> (geom i)</div><div class="sp-definition"><div class="sp-definition-body"><p style="color: red; font-weight: bold">
	  No documentation string.  Possibly unimplemented or incomplete.
	</p></div></div><br><a name="cl-ogr__fun__ogr-g-gety"></a><div class="sp-lambda-list"><b>Function ogr-g-gety</b> (geom i)</div><div class="sp-definition"><div class="sp-definition-body"><p style="color: red; font-weight: bold">
	  No documentation string.  Possibly unimplemented or incomplete.
	</p></div></div><br><a name="cl-ogr__fun__ogr-g-getz"></a><div class="sp-lambda-list"><b>Function ogr-g-getz</b> (geom i)</div><div class="sp-definition"><div class="sp-definition-body"><p style="color: red; font-weight: bold">
	  No documentation string.  Possibly unimplemented or incomplete.
	</p></div></div><br><a name="cl-ogr__fun__ogr-g-intersection"></a><div class="sp-lambda-list"><b>Function ogr-g-intersection</b> (hthis hother)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">a new geometry representing the intersection or NULL if there is no intersection or an error occurs.</div><div class="sph3">Details:</div><div class="indent">Compute intersection.<br><br>
 Generates a new geometry which is the region of intersection of the
 two geometries operated on. The OGR_G_Intersects() function can be
 used to test if two geometries intersect.<br><br>
 This function is the same as the C++ method OGRGeometry::Intersection().<br><br>
 This function is built on the GEOS library, check it for the
 definition of the geometry operation. If OGR is built without the
 GEOS library, this function will always fail, issuing a
 CPLE_NotSupported error.<br><br> the geometry. the other geometry.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-g-intersects"></a><div class="sp-lambda-list"><b>Function ogr-g-intersects</b> (hgeom hothergeom)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">TRUE if the geometries intersect, otherwise FALSE.</div><div class="sph3">Details:</div><div class="indent">Do these features intersect?<br><br>
 Currently this is not implemented in a rigerous fashion, and
 generally just tests whether the envelopes of the two features
 intersect. Eventually this will be made rigerous.<br><br>
 This function is the same as the CPP method OGRGeometry::Intersects.<br><br> handle on the first geometry.<br><br> handle on the other geometry to test against.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-g-is-empty"></a><div class="sp-lambda-list"><b>Function ogr-g-is-empty</b> (hgeom)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">TRUE if the geometry has no points, otherwise FALSE.</div><div class="sph3">Details:</div><div class="indent">Test if the geometry is empty.<br><br>
 This method is the same as the CPP method OGRGeometry::IsEmpty().<br><br> The Geometry to test.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-g-is-ring"></a><div class="sp-lambda-list"><b>Function ogr-g-is-ring</b> (hgeom)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">TRUE if the geometry has no points, otherwise FALSE.</div><div class="sph3">Details:</div><div class="indent">Test if the geometry is a ring.<br><br>
 This function is the same as the C++ method OGRGeometry::IsRing().<br><br>
 This function is built on the GEOS library, check it for the
 definition of the geometry operation. If OGR is built without the
 GEOS library, this function will always return FALSE.<br><br> The Geometry to test.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-g-is-simple"></a><div class="sp-lambda-list"><b>Function ogr-g-is-simple</b> (hgeom)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">TRUE if object is simple, otherwise FALSE.</div><div class="sph3">Details:</div><div class="indent">Returns TRUE if the geometry is simple.<br><br>
 Returns TRUE if the geometry has no anomalous geometric points, such
 as self intersection or self tangency. The description of each
 instantiable geometric class will include the specific conditions
 that cause an instance of that class to be classified as not simple.<br><br>
 This function is the same as the c++ method OGRGeometry::IsSimple()
 method.<br><br>
 If OGR is built without the GEOS library, this function will always
 return FALSE.<br><br> The Geometry to test.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-g-is-valid"></a><div class="sp-lambda-list"><b>Function ogr-g-is-valid</b> (hgeom)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">TRUE if the geometry has no points, otherwise FALSE.</div><div class="sph3">Details:</div><div class="indent">Test if the geometry is valid.<br><br>
 This function is the same as the C++ method OGRGeometry::IsValid().<br><br>
 This function is built on the GEOS library, check it for the
 definition of the geometry operation. If OGR is built without the
 GEOS library, this function will always return FALSE.<br><br> The Geometry to test.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-g-length"></a><div class="sp-lambda-list"><b>Function ogr-g-length</b> (hgeom)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">the lenght or 0.0 for unsupported geometry types.</div><div class="sph3">Details:</div><div class="indent">Compute length of a geometry.<br><br>
 Computes the area for OGRCurve or MultiCurve objects. Undefined for
 all other geometry types (returns zero).<br><br>
 This function utilizes the C++ get_Length() method.<br><br> the geometry to operate on.<br><br> <br><br> Since:OGR 1.8.0</div></div></div><br><a name="cl-ogr__fun__ogr-g-overlaps"></a><div class="sp-lambda-list"><b>Function ogr-g-overlaps</b> (hthis hother)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">TRUE if they are overlapping, otherwise FALSE.</div><div class="sph3">Details:</div><div class="indent">Test for overlap.<br><br>
 Tests if this geometry and the other geometry overlap, that is their
 intersection has a non-zero area.<br><br>
 This function is the same as the C++ method OGRGeometry::Overlaps().<br><br>
 This function is built on the GEOS library, check it for the
 definition of the geometry operation. If OGR is built without the
 GEOS library, this function will always fail, issuing a
 CPLE_NotSupported error.<br><br> the geometry to compare.<br><br> the other geometry to compare.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-g-point-on-surface"></a><div class="sp-lambda-list"><b>Function ogr-g-point-on-surface</b> (hgeom)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">a point guaranteed to lie on the surface or NULL if an error occured.</div><div class="sph3">Details:</div><div class="indent">Returns a point guaranteed to lie on the surface.<br><br>
 This method relates to the SFCOM ISurface::get_PointOnSurface()
 method however the current implementation based on GEOS can operate
 on other geometry types than the types that are supported by
 SQL/MM-Part 3 : surfaces (polygons) and
 multisurfaces (multipolygons).<br><br>
 This method is built on the GEOS library, check it for the definition
 of the geometry operation. If OGR is built without the GEOS library,
 this method will always fail, issuing a CPLE_NotSupported error.<br><br> the geometry to operate on.<br><br> <br><br> Since: OGR 1.10</div></div></div><br><a name="cl-ogr__fun__ogr-g-polygonize"></a><div class="sp-lambda-list"><b>Function ogr-g-polygonize</b> (htarget)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">a handle to a newly allocated geometry now owned by the caller, or NULL on failure.</div><div class="sph3">Details:</div><div class="indent">Polygonizes a set of sparse edges.<br><br>
 A new geometry object is created and returned containing a collection
 of reassembled Polygons: NULL will be returned if the input
 collection doesn't corresponds to a MultiLinestring, or when
 reassembling Edges into Polygons is impossible due to topogical
 inconsistencies.<br><br>
 This function is the same as the C++ method OGRGeometry::Polygonize().<br><br>
 This function is built on the GEOS library, check it for the
 definition of the geometry operation. If OGR is built without the
 GEOS library, this function will always fail, issuing a
 CPLE_NotSupported error.<br><br> The Geometry to be polygonized.<br><br> <br><br> Since: OGR 1.9.0</div></div></div><br><a name="cl-ogr__fun__ogr-g-remove-geometry"></a><div class="sp-lambda-list"><b>Function ogr-g-remove-geometry</b> (hgeom igeom bdelete)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">:NONE if successful, or :FAILURE if the index is out of range.</div><div class="sph3">Details:</div><div class="indent">Remove a geometry from an exiting geometry container.<br><br>
 Removing a geometry will cause the geometry count to drop by one, and
 all &quot;higher&quot; geometries will shuffle down one in index.<br><br>
 There is no SFCOM analog to this method.<br><br>
 This function is the same as the CPP method
 OGRGeometryCollection::removeGeometry().<br><br> the existing geometry to delete from. the index of the geometry to delete. A value of -1 is a special flag meaning that all geometries should be removed. if TRUE the geometry will be destroyed, otherwise
 it will not. The default is TRUE as the existing geometry is considered to own the geometries in it.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-g-segmentize"></a><div class="sp-lambda-list"><b>Function ogr-g-segmentize</b> (hgeom dfmaxlength)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Modify the geometry such it has no segment longer then the given
 distance.<br><br>
 Interpolated points will have Z and M values (if needed) set to
 0. Distance computation is performed in 2d only<br><br>
 This function is the same as the CPP method OGRGeometry::segmentize().<br><br> handle on the geometry to segmentize<br><br> the maximum distance between 2 points after segmentization</div></div></div><br><a name="cl-ogr__fun__ogr-g-set-point"></a><div class="sp-lambda-list"><b>Function ogr-g-set-point</b> (hgeom i dfx dfy dfz)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Set the location of a vertex in a point or linestring geometry.<br><br>
 If iPoint is larger than the number of existing points in the
 linestring, the point count will be increased to accomodate the
 request.<br><br> handle to the geometry to add a vertex to. the index of the vertex to assign (zero based) or zero for a point. input X coordinate to assign. input Y coordinate to assign. input Z coordinate to assign (defaults to zero).</div></div></div><br><a name="cl-ogr__fun__ogr-g-set-point-2d"></a><div class="sp-lambda-list"><b>Function ogr-g-set-point-2d</b> (hgeom i dfx dfy)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Set the location of a vertex in a point or linestring geometry.<br><br>
 If iPoint is larger than the number of existing points in the
 linestring, the point count will be increased to accomodate the
 request.<br><br> handle to the geometry to add a vertex to. the index of the vertex to assign (zero based) or zero for a point. input X coordinate to assign. input Y coordinate to assign.</div></div></div><br><a name="cl-ogr__fun__ogr-g-simplify"></a><div class="sp-lambda-list"><b>Function ogr-g-simplify</b> (hthis dtolerance)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">the simplified geometry or NULL if an error occurs.</div><div class="sph3">Details:</div><div class="indent">Compute a simplified geometry.<br><br>
 This function is the same as the C++ method OGRGeometry::Simplify().<br><br>
 This function is built on the GEOS library, check it for the
 definition of the geometry operation. If OGR is built without the
 GEOS library, this function will always fail, issuing a
 CPLE_NotSupported error.<br><br> the geometry.<br><br> the distance tolerance for the simplification.<br><br> <br><br> Since: OGR 1.8.0</div></div></div><br><a name="cl-ogr__fun__ogr-g-simplify-preserve-topology"></a><div class="sp-lambda-list"><b>Function ogr-g-simplify-preserve-topology</b> (hthis dtolerance)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">the simplified geometry or NULL if an error occurs.</div><div class="sph3">Details:</div><div class="indent">Simplify the geometry while preserving topology.<br><br>
 This function is the same as the C++ method
 OGRGeometry::SimplifyPreserveTopology().<br><br>
 This function is built on the GEOS library, check it for the
 definition of the geometry operation. If OGR is built without the
 GEOS library, this function will always fail, issuing a
 CPLE_NotSupported error.<br><br> the geometry.<br><br> the distance tolerance for the simplification.<br><br> <br><br> Since: OGR 1.9.0</div></div></div><br><a name="cl-ogr__fun__ogr-g-sym-difference"></a><div class="sp-lambda-list"><b>Function ogr-g-sym-difference</b> (hthis hother)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">a new geometry representing the symmetric difference or NULL if the difference is empty or an error occurs.</div><div class="sph3">Details:</div><div class="indent">Compute symmetric difference.<br><br>
 Generates a new geometry which is the symmetric difference of this
 geometry and the other geometry.<br><br>
 This function is the same as the C++ method
 OGRGeometry::SymmetricDifference().<br><br>
 This function is built on the GEOS library, check it for the
 definition of the geometry operation. If OGR is built without the
 GEOS library, this function will always fail, issuing a
 CPLE_NotSupported error.<br><br> the geometry.<br><br> the other geometry.<br><br> <br><br> Since: OGR 1.8.0</div></div></div><br><a name="cl-ogr__fun__ogr-g-touches"></a><div class="sp-lambda-list"><b>Function ogr-g-touches</b> (hthis hother)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">TRUE if they are touching, otherwise FALSE.</div><div class="sph3">Details:</div><div class="indent">Test for touching.<br><br>
 Tests if this geometry and the other geometry are touching.<br><br>
 This function is the same as the C++ method OGRGeometry::Touches().<br><br>
 This function is built on the GEOS library, check it for the
 definition of the geometry operation. If OGR is built without the
 GEOS library, this function will always fail, issuing a
 CPLE_NotSupported error.<br><br> the geometry to compare.<br><br> the other geometry to compare.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-g-transform"></a><div class="sp-lambda-list"><b>Function ogr-g-transform</b> (hgeom htransform)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">:NONE on success or an error code.</div><div class="sph3">Details:</div><div class="indent">Apply arbitrary coordinate transformation to geometry.<br><br>
 This function will transform the coordinates of a geometry from their
 current spatial reference system to a new target spatial reference
 system. Normally this means reprojecting the vectors, but it could
 include datum shifts, and changes of units.<br><br>
 Note that this function does not require that the geometry already
 have a spatial reference system. It will be assumed that they can be
 treated as having the source spatial reference system of the
 OGRCoordinateTransformation object, and the actual SRS of the
 geometry will be ignored. On successful completion the output
 OGRSpatialReference of the OGRCoordinateTransformation will be
 assigned to the geometry.<br><br>
 This function is the same as the CPP method OGRGeometry::transform.<br><br> handle on the geometry to apply the transform to.<br><br> handle on the transformation to apply.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-g-transform-to"></a><div class="sp-lambda-list"><b>Function ogr-g-transform-to</b> (hgeom hsrs)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">:NONE on success, or an error code.</div><div class="sph3">Details:</div><div class="indent">Transform geometry to new spatial reference system.<br><br>
 This function will transform the coordinates of a geometry from their
 current spatial reference system to a new target spatial reference
 system. Normally this means reprojecting the vectors, but it could
 include datum shifts, and changes of units.<br><br>
 This function will only work if the geometry already has an assigned
 spatial reference system, and if it is transformable to the target
 coordinate system.<br><br>
 Because this function requires internal creation and initialization
 of an OGRCoordinateTransformation object it is significantly more
 expensive to use this function to transform many geometries than it
 is to create the OGRCoordinateTransformation in advance, and call
 transform() with that transformation. This function exists primarily
 for convenience when only transforming a single geometry.<br><br>
 This function is the same as the CPP method OGRGeometry::transformTo.<br><br> handle on the geometry to apply the transform to.<br><br> handle on the spatial reference system to apply.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-g-union"></a><div class="sp-lambda-list"><b>Function ogr-g-union</b> (hthis hother)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">a new geometry representing the union or NULL if an error occurs.</div><div class="sph3">Details:</div><div class="indent">Compute union.<br><br>
 Generates a new geometry which is the region of union of the two
 geometries operated on.<br><br>
 This function is the same as the C++ method OGRGeometry::Union().<br><br>
 This function is built on the GEOS library, check it for the
 definition of the geometry operation. If OGR is built without the
 GEOS library, this function will always fail, issuing a
 CPLE_NotSupported error.<br><br> the geometry.<br><br> the other geometry.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-g-union-cascaded"></a><div class="sp-lambda-list"><b>Function ogr-g-union-cascaded</b> (hthis)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">a new geometry representing the union or NULL if an error occurs.</div><div class="sph3">Details:</div><div class="indent">Compute union using cascading.<br><br>
 This function is the same as the C++ method
 OGRGeometry::UnionCascaded().<br><br>
 This function is built on the GEOS library, check it for the
 definition of the geometry operation. If OGR is built without the
 GEOS library, this function will always fail, issuing a
 CPLE_NotSupported error.<br><br> the geometry.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-g-within"></a><div class="sp-lambda-list"><b>Function ogr-g-within</b> (hthis hother)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">TRUE if hThis is within hOther, otherwise FALSE.</div><div class="sph3">Details:</div><div class="indent">Test for containment.<br><br>
 Tests if this geometry is within the other geometry.<br><br>
 This function is the same as the C++ method OGRGeometry::Within().<br><br>
 This function is built on the GEOS library, check it for the
 definition of the geometry operation. If OGR is built without the
 GEOS library, this function will always fail, issuing a
 CPLE_NotSupported error.<br><br> the geometry to compare.<br><br> the other geometry to compare.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-get-driver"></a><div class="sp-lambda-list"><b>Function ogr-get-driver</b> (idriver)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">handle to the driver, or NULL if iDriver is out of range.</div><div class="sph3">Details:</div><div class="indent">Fetch the indicated driver.<br><br>
 This function is the same as the C++ method
 OGRSFDriverRegistrar::GetDriver().<br><br> the driver index, from 0 to GetDriverCount()-1.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-get-driver-by-name"></a><div class="sp-lambda-list"><b>Function ogr-get-driver-by-name</b> (pszname)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">the driver, or NULL if no driver with that name is found</div><div class="sph3">Details:</div><div class="indent">Fetch the indicated driver.<br><br>
 This function is the same as the C++ method
 OGRSFDriverRegistrar::GetDriverByName()<br><br> the driver name<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-get-driver-count"></a><div class="sp-lambda-list"><b>Function ogr-get-driver-count</b> ()</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">the drivers count.</div><div class="sph3">Details:</div><div class="indent">Fetch the number of registered drivers.<br><br>
 This function is the same as the C++ method
 OGRSFDriverRegistrar::GetDriverCount().<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-get-field-type-name"></a><div class="sp-lambda-list"><b>Function ogr-get-field-type-name</b> (etype)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">the name.</div><div class="sph3">Details:</div><div class="indent">Fetch human readable name for a field type.<br><br>
 This function is the same as the CPP method OGRFieldDefn::GetFieldTypeName().<br><br> the field type to get name for.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-get-open-ds"></a><div class="sp-lambda-list"><b>Function ogr-get-open-ds</b> (ids)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Return the iDS th datasource opened.<br><br>
 This function is the same as the C++ method
 OGRSFDriverRegistrar::GetOpenDS.<br><br> the index of the dataset to return (between 0 and GetOpenDSCount() - 1)</div></div></div><br><a name="cl-ogr__fun__ogr-get-open-ds-count"></a><div class="sp-lambda-list"><b>Function ogr-get-open-ds-count</b> ()</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">the number of opened datasources.</div><div class="sph3">Details:</div><div class="indent">Return the number of opened datasources.<br><br>
 This function is the same as the C++ method
 OGRSFDriverRegistrar::GetOpenDSCount()<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-gfld-create"></a><div class="sp-lambda-list"><b>Function ogr-gfld-create</b> (pszname etype)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">handle to the new field definition.</div><div class="sph3">Details:</div><div class="indent">Create a new field geometry definition.<br><br>
 This function is the same as the CPP method
 OGRGeomFieldDefn::OGRGeomFieldDefn().<br><br> the name of the new field definition. the type of the new field definition.<br><br>  Since: GDAL 2.0</div></div></div><br><a name="cl-ogr__fun__ogr-gfld-destroy"></a><div class="sp-lambda-list"><b>Function ogr-gfld-destroy</b> (hdefn)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Destroy a geometry field definition.<br><br> handle to the geometry field definition to destroy.<br><br> Since: GDAL 2.0</div></div></div><br><a name="cl-ogr__fun__ogr-gfld-get-name-ref"></a><div class="sp-lambda-list"><b>Function ogr-gfld-get-name-ref</b> (hdefn)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">the name of the geometry field definition.</div><div class="sph3">Details:</div><div class="indent">Fetch name of this field.<br><br>
 This function is the same as the CPP method
 OGRGeomFieldDefn::GetNameRef().<br><br> handle to the geometry field definition.<br><br>  Since: GDAL 2.0</div></div></div><br><a name="cl-ogr__fun__ogr-gfld-get-spatial-ref"></a><div class="sp-lambda-list"><b>Function ogr-gfld-get-spatial-ref</b> (hdefn)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">field spatial reference system.</div><div class="sph3">Details:</div><div class="indent">Fetch spatial reference system of this field.<br><br>
 This function is the same as the C++ method
 OGRGeomFieldDefn::GetSpatialRef().<br><br> handle to the geometry field definition<br><br>  Since: GDAL 2.0</div></div></div><br><a name="cl-ogr__fun__ogr-gfld-get-type"></a><div class="sp-lambda-list"><b>Function ogr-gfld-get-type</b> (hdefn)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">field geometry type.</div><div class="sph3">Details:</div><div class="indent">Fetch geometry type of this field.<br><br>
 This function is the same as the CPP method
 OGRGeomFieldDefn::GetType().<br><br> handle to the geometry field definition to get type from.<br><br>  Since: GDAL 2.0</div></div></div><br><a name="cl-ogr__fun__ogr-gfld-is-ignored"></a><div class="sp-lambda-list"><b>Function ogr-gfld-is-ignored</b> (hdefn)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">ignore state</div><div class="sph3">Details:</div><div class="indent">Return whether this field should be omitted when fetching features.<br><br>
 This method is the same as the C++ method
 OGRGeomFieldDefn::IsIgnored().<br><br> handle to the geometry field definition<br><br>  Since: GDAL 2.0</div></div></div><br><a name="cl-ogr__fun__ogr-gfld-set-ignored"></a><div class="sp-lambda-list"><b>Function ogr-gfld-set-ignored</b> (hdefn ignore)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Set whether this field should be omitted when fetching features.<br><br>
 This method is the same as the C++ method
 OGRGeomFieldDefn::SetIgnored().<br><br> handle to the geometry field definition ignore state<br><br> Since: GDAL 2.0</div></div></div><br><a name="cl-ogr__fun__ogr-gfld-set-name"></a><div class="sp-lambda-list"><b>Function ogr-gfld-set-name</b> (hdefn pszname)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Reset the name of this field.<br><br>
 This function is the same as the CPP method
 OGRGeomFieldDefn::SetName().<br><br> handle to the geometry field definition to apply the new name to. the new name to apply.<br><br> Since: GDAL 2.0</div></div></div><br><a name="cl-ogr__fun__ogr-gfld-set-spatial-ref"></a><div class="sp-lambda-list"><b>Function ogr-gfld-set-spatial-ref</b> (hdefn hsrs)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Set the spatial reference of this field.<br><br>
 This function is the same as the C++ method
 OGRGeomFieldDefn::SetSpatialRef().<br><br>
 This function drops the reference of the previously set SRS object
 and acquires a new reference on the passed object (if non-NULL).<br><br> handle to the geometry field definition the new SRS to apply.<br><br> Since: GDAL 2.0</div></div></div><br><a name="cl-ogr__fun__ogr-gfld-set-type"></a><div class="sp-lambda-list"><b>Function ogr-gfld-set-type</b> (hdefn etype)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Set the geometry type of this field. This should never be done to an
 OGRGeomFieldDefn that is already part of an OGRFeatureDefn.<br><br>
 This function is the same as the CPP method
 OGRGeomFieldDefn::SetType().<br><br> handle to the geometry field definition to set type to. the new field geometry type.<br><br> Since: GDAL 2.0</div></div></div><br><a name="cl-ogr__fun__ogr-l-alter-field-defn"></a><div class="sp-lambda-list"><b>Function ogr-l-alter-field-defn</b> (hlayer ifield hnewfielddefn nflags)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">OGRERR_NONE on success.</div><div class="sph3">Details:</div><div class="indent">Alter the definition of an existing field on a layer.<br><br>
 You must use this to alter the definition of an existing field of a
 real layer. Internally the OGRFeatureDefn for the layer will be
 updated to reflect the altered field. Applications should never
 modify the OGRFeatureDefn used by a layer directly.<br><br>
 This function should not be called while there are feature objects in
 existance that were obtained or created with the previous layer
 definition.<br><br>
 Not all drivers support this function. You can query a layer to check
 if it supports it with the OLCAlterFieldDefn capability. Some drivers
 may only support this method while there are still no features in the
 layer. When it is supported, the existings features of the backing
 file/database should be updated accordingly. Some drivers might also
 not support all update flags.<br><br>
 This function is the same as the C++ method OGRLayer::AlterFieldDefn().<br><br> handle to the layer. index of the field whose definition must be altered. new field definition combination of ALTER_NAME_FLAG, ALTER_TYPE_FLAG and
 ALTER_WIDTH_PRECISION_FLAG to indicate which of the name and/or type
 and/or width and precision fields from the new field definition must be taken into account.<br><br> <br><br> Since: OGR 1.9.0</div></div></div><br><a name="cl-ogr__fun__ogr-l-clip"></a><div class="sp-lambda-list"><b>Function ogr-l-clip</b> (playerinput playermethod playerresult papszoptions pfnprogress pprogressarg)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</div><div class="sph3">Details:</div><div class="indent">Clip off areas that are not covered by the method layer.<br><br>
 The result layer contains features whose geometries represent areas
 that are in the input layer and in the method layer. The features in
 the result layer have the (possibly clipped) areas of features in the
 input layer and the attributes from the same features. The schema of
 the result layer can be set by the user or, if it is empty, is
 initialized to contain all fields in the input layer.<br><br>
 Note: For best performance use the minimum amount of features in the
 method layer and copy it into a memory layer.<br><br>
 This method relies on GEOS support. Do not use unless the GEOS
 support is compiled in.<br><br>
The recognized list of options is :
 SKIP_FAILURES=YES/NO. Set it to YES to go on, even when a feature could not be inserted.
 PROMOTE_TO_MULTI=YES/NO. Set it to YES to convert Polygons into MultiPolygons, or LineStrings to MultiLineStrings.
 INPUT_PREFIX=string. Set a prefix for the field names that will be created from the fields of the input layer.
 METHOD_PREFIX=string. Set a prefix for the field names that will be created from the fields of the method layer.<br><br>
 This function is the same as the C++ method OGRLayer::Clip().<br><br> the input layer. Should not be NULL. the method layer. Should not be NULL. the layer where the features resulting from
 the operation are inserted. Should not be NULL. See above the note about the schema. NULL terminated list of options (may be NULL). a GDALProgressFunc() compatible callback function for reporting progress or NULL. argument to be passed to pfnProgress. May be NULL.<br><br> <br><br> Since: OGR 1.10</div></div></div><br><a name="cl-ogr__fun__ogr-l-commit-transaction"></a><div class="sp-lambda-list"><b>Function ogr-l-commit-transaction</b> (hlayer)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">OGRERR_NONE on success.</div><div class="sph3">Details:</div><div class="indent">For datasources which support transactions, CommitTransaction commits
 a transaction.<br><br>
 If no transaction is active, or the commit fails, will return
 OGRERR_FAILURE. Datasources which do not support transactions will
 always return OGRERR_NONE.<br><br>
 This function is the same as the C++ method
 OGRLayer::CommitTransaction().<br><br> handle to the layer<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-l-create-feature"></a><div class="sp-lambda-list"><b>Function ogr-l-create-feature</b> (hlayer hfeat)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">OGRERR_NONE on success.</div><div class="sph3">Details:</div><div class="indent">Create and write a new feature within a layer.<br><br>
 The passed feature is written to the layer as a new feature, rather
 than overwriting an existing one. If the feature has a feature id
 other than OGRNullFID, then the native implementation may use that as
 the feature id of the new feature, but not necessarily. Upon
 successful return the passed feature will have been updated with the
 new feature id.<br><br>
 This function is the same as the C++ method
 OGRLayer::CreateFeature().<br><br> handle to the layer to write the feature to. the handle of the feature to write to disk.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-l-create-field"></a><div class="sp-lambda-list"><b>Function ogr-l-create-field</b> (hlayer hfield bapproxok)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">OGRERR_NONE on success.</div><div class="sph3">Details:</div><div class="indent">Create a new field on a layer.<br><br>
 You must use this to create new fields on a real layer. Internally
 the OGRFeatureDefn for the layer will be updated to reflect the new
 field. Applications should never modify the OGRFeatureDefn used by a
 layer directly.<br><br>
 This function should not be called while there are feature objects in
 existance that were obtained or created with the previous layer
 definition.<br><br>
 Not all drivers support this function. You can query a layer to check
 if it supports it with the OLCCreateField capability. Some drivers
 may only support this method while there are still no features in the
 layer. When it is supported, the existings features of the backing
 file/database should be updated accordingly.<br><br>
 This function is the same as the C++ method OGRLayer::CreateField().<br><br> handle to the layer to write the field definition. handle of the field definition to write to disk. If TRUE, the field may be created in a slightly different form depending on the limitations of the format driver.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-l-create-geom-field"></a><div class="sp-lambda-list"><b>Function ogr-l-create-geom-field</b> (hlayer hfield bapproxok)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">OGRERR_NONE on success.</div><div class="sph3">Details:</div><div class="indent">Create a new geometry field on a layer.<br><br>
 You must use this to create new geometry fields on a real
 layer. Internally the OGRFeatureDefn for the layer will be updated to
 reflect the new field. Applications should never modify the
 OGRFeatureDefn used by a layer directly.<br><br>
 This function should not be called while there are feature objects in
 existance that were obtained or created with the previous layer
 definition.<br><br>
 Not all drivers support this function. You can query a layer to check
 if it supports it with the OLCCreateField capability. Some drivers
 may only support this method while there are still no features in the
 layer. When it is supported, the existings features of the backing
 file/database should be updated accordingly.<br><br>
 This function is the same as the C++ method OGRLayer::CreateField().<br><br> handle to the layer to write the field definition. handle of the geometry field definition to write to disk. If TRUE, the field may be created in a slightly different form depending on the limitations of the format driver.<br><br> <br><br> Since: OGR 2.0</div></div></div><br><a name="cl-ogr__fun__ogr-l-delete-feature"></a><div class="sp-lambda-list"><b>Function ogr-l-delete-feature</b> (hlayer nfid)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">OGRERR_NONE on success.</div><div class="sph3">Details:</div><div class="indent">Delete feature from layer.<br><br>
 The feature with the indicated feature id is deleted from the layer
 if supported by the driver. Most drivers do not support feature
 deletion, and will return OGRERR_UNSUPPORTED_OPERATION. The
 OGR_L_TestCapability() function may be called with OLCDeleteFeature
 to check if the driver supports feature deletion.<br><br>
 This method is the same as the C++ method OGRLayer::DeleteFeature().<br><br> handle to the layer the feature id to be deleted from the layer<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-l-delete-field"></a><div class="sp-lambda-list"><b>Function ogr-l-delete-field</b> (hlayer ifield)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">:NONE on success.</div><div class="sph3">Details:</div><div class="indent">Create a new field on a layer.<br><br>
 You must use this to delete existing fields on a real
 layer. Internally the OGRFeatureDefn for the layer will be updated to
 reflect the deleted field. Applications should never modify the
 OGRFeatureDefn used by a layer directly.<br><br>
 This function should not be called while there are feature objects in
 existance that were obtained or created with the previous layer
 definition.<br><br>
 Not all drivers support this function. You can query a layer to check
 if it supports it with the OLCDeleteField capability. Some drivers
 may only support this method while there are still no features in the
 layer. When it is supported, the existings features of the backing
 file/database should be updated accordingly.<br><br>
 This function is the same as the C++ method OGRLayer::DeleteField().<br><br> handle to the layer. index of the field to delete.<br><br> <br><br> Since: OGR 1.9.0</div></div></div><br><a name="cl-ogr__fun__ogr-l-erase"></a><div class="sp-lambda-list"><b>Function ogr-l-erase</b> (playerinput playermethod playerresult papszoptions pfnprogress pprogressarg)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</div><div class="sph3">Details:</div><div class="indent">Remove areas that are covered by the method layer.<br><br>
 The result layer contains features whose geometries represent areas
 that are in the input layer but not in the method layer. The features
 in the result layer have attributes from the input layer. The schema
 of the result layer can be set by the user or, if it is empty, is
 initialized to contain all fields in the input layer.<br><br>
 Note: For best performance use the minimum amount of features in the
 method layer and copy it into a memory layer.<br><br>
 This method relies on GEOS support. Do not use unless the GEOS
 support is compiled in.<br><br>
The recognized list of options is :
 SKIP_FAILURES=YES/NO. Set it to YES to go on, even when a feature could not be inserted.
 PROMOTE_TO_MULTI=YES/NO. Set it to YES to convert Polygons into MultiPolygons, or LineStrings to MultiLineStrings.
 INPUT_PREFIX=string. Set a prefix for the field names that will be created from the fields of the input layer.
 METHOD_PREFIX=string. Set a prefix for the field names that will be created from the fields of the method layer.<br><br>
 This function is the same as the C++ method OGRLayer::Erase().<br><br> the input layer. Should not be NULL. the method layer. Should not be NULL. the layer where the features resulting from
 the operation are inserted. Should not be NULL. See above the note about the schema. NULL terminated list of options (may be NULL). a GDALProgressFunc() compatible callback function for reporting progress or NULL. argument to be passed to pfnProgress. May be NULL.<br><br> <br><br> Since: OGR 1.10</div></div></div><br><a name="cl-ogr__fun__ogr-l-get-extent"></a><div class="sp-lambda-list"><b>Function ogr-l-get-extent</b> (hlayer psextent bforce)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">OGRERR_NONE on success, OGRERR_FAILURE if extent not known.</div><div class="sph3">Details:</div><div class="indent">Fetch the extent of this layer.<br><br>
 Returns the extent (MBR) of the data in the layer. If bForce is
 FALSE, and it would be expensive to establish the extent then
 OGRERR_FAILURE will be returned indicating that the extent isn't
 know. If bForce is TRUE then some implementations will actually scan
 the entire layer once to compute the MBR of all the features in the
 layer.<br><br>
 Depending on the drivers, the returned extent may or may not take the
 spatial filter into account. So it is safer to call OGR_L_GetExtent()
 without setting a spatial filter.<br><br>
 Layers without any geometry may return OGRERR_FAILURE just indicating
 that no meaningful extents could be collected.<br><br>
 Note that some implementations of this method may alter the read
 cursor of the layer.<br><br>
 This function is the same as the C++ method OGRLayer::GetExtent().<br><br> handle to the layer from which to get extent. the structure in which the extent value will be returned. Flag indicating whether the extent should be computed even if it is expensive.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-l-get-extent-ex"></a><div class="sp-lambda-list"><b>Function ogr-l-get-extent-ex</b> (hlayer igeomfield psextent bforce)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">OGRERR_NONE on success, OGRERR_FAILURE if extent not known.</div><div class="sph3">Details:</div><div class="indent">Fetch the extent of this layer, on the specified geometry field.<br><br>
 Returns the extent (MBR) of the data in the layer. If bForce is
 FALSE, and it would be expensive to establish the extent then
 OGRERR_FAILURE will be returned indicating that the extent isn't
 know. If bForce is TRUE then some implementations will actually scan
 the entire layer once to compute the MBR of all the features in the
 layer.<br><br>
 Depending on the drivers, the returned extent may or may not take the
 spatial filter into account. So it is safer to call OGR_L_GetExtent()
 without setting a spatial filter.<br><br>
 Layers without any geometry may return OGRERR_FAILURE just indicating
 that no meaningful extents could be collected.<br><br>
 Note that some implementations of this method may alter the read
 cursor of the layer.<br><br>
 This function is the same as the C++ method OGRLayer::GetExtent().<br><br> handle to the layer from which to get extent. the index of the geometry field on which to compute the extent. the structure in which the extent value will be returned. Flag indicating whether the extent should be computed even if it is expensive.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-l-get-feature"></a><div class="sp-lambda-list"><b>Function ogr-l-get-feature</b> (hlayer nfeatureid)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">an handle to a feature now owned by the caller, or NULL on failure.</div><div class="sph3">Details:</div><div class="indent">Fetch a feature by its identifier.<br><br>
 This function will attempt to read the identified feature. The nFID
 value cannot be OGRNullFID. Success or failure of this operation is
 unaffected by the spatial or attribute filters.<br><br>
 If this function returns a non-NULL feature, it is guaranteed that
 its feature id (OGR_F_GetFID()) will be the same as nFID.<br><br>
 Use OGR_L_TestCapability(OLCRandomRead) to establish if this layer
 supports efficient random access reading via OGR_L_GetFeature();
 however, the call should always work if the feature exists as a
 fallback implementation just scans all the features in the layer
 looking for the desired feature.<br><br>
 Sequential reads are generally considered interrupted by a
 OGR_L_GetFeature() call.<br><br>
 The returned feature should be free with OGR_F_Destroy().<br><br>
 This function is the same as the C++ method OGRLayer::GetFeature( ).<br><br> handle to the layer that owned the feature. the feature id of the feature to read.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-l-get-feature-count"></a><div class="sp-lambda-list"><b>Function ogr-l-get-feature-count</b> (hlayer bforce)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">feature count, -1 if count not known.</div><div class="sph3">Details:</div><div class="indent">Fetch the feature count in this layer.<br><br>
 Returns the number of features in the layer. For dynamic databases
 the count may not be exact. If bForce is FALSE, and it would be
 expensive to establish the feature count a value of -1 may be
 returned indicating that the count isn't know. If bForce is TRUE some
 implementations will actually scan the entire layer once to count
 objects.<br><br>
 The returned count takes the spatial filter into account.<br><br>
 Note that some implementations of this method may alter the read
 cursor of the layer.<br><br>
 This function is the same as the CPP OGRLayer::GetFeatureCount().<br><br> handle to the layer that owned the features. Flag indicating whether the count should be computed even if it is expensive.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-l-get-geom-type"></a><div class="sp-lambda-list"><b>Function ogr-l-get-geom-type</b> (hlayer)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">the geometry type</div><div class="sph3">Details:</div><div class="indent">Return the layer geometry type.<br><br>
 This returns the same result as
 OGR_FD_GetGeomType(OGR_L_GetLayerDefn(hLayer)), but for a few
 drivers, calling OGR_L_GetGeomType() directly can avoid lengthy layer
 definition initialization.<br><br>
 This function is the same as the C++ method OGRLayer::GetGeomType().<br><br> handle to the layer.<br><br> <br><br> Since: OGR 1.8.0</div></div></div><br><a name="cl-ogr__fun__ogr-l-get-layer-defn"></a><div class="sp-lambda-list"><b>Function ogr-l-get-layer-defn</b> (hlayer)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">OGRFeatureDefnH an handle to the feature definition.</div><div class="sph3">Details:</div><div class="indent">Fetch the schema information for this layer.<br><br>
 The returned handle to the OGRFeatureDefn is owned by the OGRLayer,
 and should not be modified or freed by the application. It
 encapsulates the attribute schema of the features of the layer.<br><br>
 This function is the same as the C++ method OGRLayer::GetLayerDefn().<br><br> handle to the layer to get the schema information.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-l-get-name"></a><div class="sp-lambda-list"><b>Function ogr-l-get-name</b> (hlayer)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">the layer name (must not been freed)</div><div class="sph3">Details:</div><div class="indent">Return the layer name.<br><br>
 This returns the same content as
 OGR_FD_GetName(OGR_L_GetLayerDefn(hLayer)), but for a few drivers,
 calling OGR_L_GetName() directly can avoid lengthy layer definition
 initialization.<br><br>
 This function is the same as the C++ method OGRLayer::GetName().<br><br> handle to the layer.<br><br> <br><br> Since: OGR 1.8.0</div></div></div><br><a name="cl-ogr__fun__ogr-l-get-next-feature"></a><div class="sp-lambda-list"><b>Function ogr-l-get-next-feature</b> (hlayer)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">an handle to a feature, or NULL if no more features are available.</div><div class="sph3">Details:</div><div class="indent">Fetch the next available feature from this layer.<br><br>
 The returned feature becomes the responsiblity of the caller to delete
 with OGR_F_Destroy(). It is critical that all features associated with
 an OGRLayer (more specifically an OGRFeatureDefn) be deleted before
 that layer/datasource is deleted.<br><br>
 Only features matching the current spatial filter (set with
 SetSpatialFilter()) will be returned.<br><br>
 This function implements sequential access to the features of a
 layer. The OGR_L_ResetReading() function can be used to start at the
 beginning again.<br><br>
 This function is the same as the C++ method
 OGRLayer::GetNextFeature().<br><br> handle to the layer from which feature are read.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-l-get-spatial-filter"></a><div class="sp-lambda-list"><b>Function ogr-l-get-spatial-filter</b> (hlayer)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">an handle to the spatial filter geometry.</div><div class="sph3">Details:</div><div class="indent">This function returns the current spatial filter for this layer.<br><br>
 The returned pointer is to an internally owned object, and should not
 be altered or deleted by the caller.<br><br>
 This function is the same as the C++ method OGRLayer::GetSpatialFilter().<br><br> handle to the layer to get the spatial filter from.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-l-get-spatial-ref"></a><div class="sp-lambda-list"><b>Function ogr-l-get-spatial-ref</b> (hlayer)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">spatial reference, or NULL if there isn't one.</div><div class="sph3">Details:</div><div class="indent">Fetch the spatial reference system for this layer.<br><br>
 The returned object is owned by the OGRLayer and should not be
 modified or freed by the application.<br><br>
 This function is the same as the C++ method OGRLayer::GetSpatialRef().<br><br> handle to the layer to get the spatial reference from.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-l-identity"></a><div class="sp-lambda-list"><b>Function ogr-l-identity</b> (playerinput playermethod playerresult papszoptions pfnprogress pprogressarg)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</div><div class="sph3">Details:</div><div class="indent">Identify the features of this layer with the ones from the identity
 layer.<br><br>
 The result layer contains features whose geometries represent areas
 that are in the input layer. The features in the result layer have
 attributes from both input and method layers. The schema of the
 result layer can be set by the user or, if it is empty, is
 initialized to contain all fields in input and method layers.<br><br>
 Note: If the schema of the result is set by user and contains fields
 that have the same name as a field in input and in method layer, then
 the attribute in the result feature will get the value from the
 feature of the method layer (even if it is undefined).<br><br>
 For best performance use the minimum amount of features in the method
 layer and copy it into a memory layer.<br><br>
 This method relies on GEOS support. Do not use unless the GEOS
 support is compiled in.<br><br>
The recognized list of options is :
 SKIP_FAILURES=YES/NO. Set it to YES to go on, even when a feature could not be inserted.
 PROMOTE_TO_MULTI=YES/NO. Set it to YES to convert Polygons into MultiPolygons, or LineStrings to MultiLineStrings.
 INPUT_PREFIX=string. Set a prefix for the field names that will be created from the fields of the input layer.
 METHOD_PREFIX=string. Set a prefix for the field names that will be created from the fields of the method layer.<br><br>
 This function is the same as the C++ method OGRLayer::Identity().<br><br> the input layer. Should not be NULL. the method layer. Should not be NULL. the layer where the features resulting from
 the operation are inserted. Should not be NULL. See above the note about the schema. NULL terminated list of options (may be NULL). a GDALProgressFunc() compatible callback function for reporting progress or NULL. argument to be passed to pfnProgress. May be NULL.<br><br> <br><br> Since: OGR 1.10</div></div></div><br><a name="cl-ogr__fun__ogr-l-intersection"></a><div class="sp-lambda-list"><b>Function ogr-l-intersection</b> (playerinput playermethod playerresult papszoptions pfnprogress pprogressarg)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</div><div class="sph3">Details:</div><div class="indent">Intersection of two layers.<br><br>
 The result layer contains features whose geometries represent areas
 that are common between features in the input layer and in the method
 layer. The features in the result layer have attributes from both
 input and method layers. The schema of the result layer can be set by
 the user or, if it is empty, is initialized to contain all fields in
 the input and method layers.<br><br>
 Note: If the schema of the result is set by user and contains fields
 that have the same name as a field in input and in method layer, then
 the attribute in the result feature will get the value from the
 feature of the method layer.<br><br>
 For best performance use the minimum amount of features in the method
 layer and copy it into a memory layer.<br><br>
 This method relies on GEOS support. Do not use unless the GEOS
 support is compiled in.<br><br>
The recognized list of options is :
 SKIP_FAILURES=YES/NO. Set it to YES to go on, even when a feature could not be inserted.
 PROMOTE_TO_MULTI=YES/NO. Set it to YES to convert Polygons into MultiPolygons, or LineStrings to MultiLineStrings.
 INPUT_PREFIX=string. Set a prefix for the field names that will be created from the fields of the input layer.
 METHOD_PREFIX=string. Set a prefix for the field names that will be created from the fields of the method layer.<br><br>
 This function is the same as the C++ method OGRLayer::Intersection().<br><br> the input layer. Should not be NULL. the method layer. Should not be NULL. the layer where the features resulting from
 the operation are inserted. Should not be NULL. See above the note about the schema. NULL terminated list of options (may be NULL). a GDALProgressFunc() compatible callback function for reporting progress or NULL. argument to be passed to pfnProgress. May be NULL.<br><br> <br><br> Since: OGR 1.10</div></div></div><br><a name="cl-ogr__fun__ogr-l-reorder-field"></a><div class="sp-lambda-list"><b>Function ogr-l-reorder-field</b> (hlayer ioldfieldpos inewfieldpos)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">:NONE on success.</div><div class="sph3">Details:</div><div class="indent">Reorder an existing field on a layer.<br><br>
 This function is a conveniency wrapper of OGR_L_ReorderFields()
 dedicated to move a single field.<br><br>
 You must use this to reorder existing fields on a real
 layer. Internally the OGRFeatureDefn for the layer will be updated to
 reflect the reordering of the fields. Applications should never
 modify the OGRFeatureDefn used by a layer directly.<br><br>
 This function should not be called while there are feature objects in
 existance that were obtained or created with the previous layer
 definition.<br><br>
 The field definition that was at initial position iOldFieldPos will
 be moved at position iNewFieldPos, and elements between will be
 shuffled accordingly.<br><br>
 For example, let suppose the fields were
 &quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot; initially. ReorderField(1, 3) will
 reorder them as &quot;0&quot;,&quot;2&quot;,&quot;3&quot;,&quot;1&quot;,&quot;4&quot;.<br><br>
 Not all drivers support this function. You can query a layer to check
 if it supports it with the OLCReorderFields capability. Some drivers
 may only support this method while there are still no features in the
 layer. When it is supported, the existings features of the backing
 file/database should be updated accordingly.<br><br>
 This function is the same as the C++ method OGRLayer::ReorderField().<br><br> handle to the layer. previous position of the field to move. Must be in the range [0,GetFieldCount()-1]. new position of the field to move. Must be in the range [0,GetFieldCount()-1].<br><br> <br><br> Since: OGR 1.9.0</div></div></div><br><a name="cl-ogr__fun__ogr-l-reorder-fields"></a><div class="sp-lambda-list"><b>Function ogr-l-reorder-fields</b> (hlayer panmap)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">OGRERR_NONE on success.</div><div class="sph3">Details:</div><div class="indent">Reorder all the fields of a layer.<br><br>
 You must use this to reorder existing fields on a real
 layer. Internally the OGRFeatureDefn for the layer will be updated to
 reflect the reordering of the fields. Applications should never
 modify the OGRFeatureDefn used by a layer directly.<br><br>
 This function should not be called while there are feature objects in
 existance that were obtained or created with the previous layer
 definition.<br><br>
 panMap is such that,for each field definition at position i after
 reordering, its position before reordering was panMap[i].<br><br>
 For example, let suppose the fields were &quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;
 initially. ReorderFields([0,2,3,1,4]) will reorder them
 as &quot;0&quot;,&quot;2&quot;,&quot;3&quot;,&quot;1&quot;,&quot;4&quot;.<br><br>
 Not all drivers support this function. You can query a layer to check
 if it supports it with the OLCReorderFields capability. Some drivers
 may only support this method while there are still no features in the
 layer. When it is supported, the existings features of the backing
 file/database should be updated accordingly.<br><br>
 This function is the same as the C++ method
 OGRLayer::ReorderFields().<br><br> handle to the layer. an array of GetLayerDefn()-&gt;GetFieldCount()
 elements which is a permutation of [0, GetLayerDefn()-&gt;GetFieldCount()-1].<br><br> <br><br> Since: OGR 1.9.0</div></div></div><br><a name="cl-ogr__fun__ogr-l-reset-reading"></a><div class="sp-lambda-list"><b>Function ogr-l-reset-reading</b> (hlayer)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Reset feature reading to start on the first feature.<br><br>
 This affects GetNextFeature().<br><br>
 This function is the same as the C++ method OGRLayer::ResetReading().<br><br> handle to the layer on which features are read.</div></div></div><br><a name="cl-ogr__fun__ogr-l-rollback-transaction"></a><div class="sp-lambda-list"><b>Function ogr-l-rollback-transaction</b> (hlayer)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">OGRERR_NONE on success.</div><div class="sph3">Details:</div><div class="indent">For datasources which support transactions, RollbackTransaction will
  roll back a datasource to its state before the start of the current
  transaction. If no transaction is active, or the rollback fails, will
  return OGRERR_FAILURE. Datasources which do not support transactions
  will always return OGRERR_NONE.<br><br>
  This function is the same as the C++ method
  OGRLayer::RollbackTransaction().<br><br>  handle to the layer<br><br>  </div></div></div><br><a name="cl-ogr__fun__ogr-l-set-attribute-filter"></a><div class="sp-lambda-list"><b>Function ogr-l-set-attribute-filter</b> (hlayer pszquery)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">OGRERR_NONE if successfully installed, or an error code if the query expression is in error, or some other failure occurs.</div><div class="sph3">Details:</div><div class="indent">Set a new attribute query.<br><br>
 This function sets the attribute query string to be used when
 fetching features via the OGR_L_GetNextFeature() function. Only
 features for which the query evaluates as true will be returned.<br><br>
 The query string should be in the format of an SQL WHERE clause. For
 instance &quot;population &gt; 1000000 and population &lt; 5000000&quot; where
 population is an attribute in the layer. The query format is a
 restricted form of SQL WHERE clause as
 defined &quot;eq_format=restricted_where&quot; about half way through this
 document:<br><br>
 http://ogdi.sourceforge.net/prop/6.2.CapabilitiesMetadata.html<br><br>
 Note that installing a query string will generally result in
 resetting the current reading position (ala OGR_L_ResetReading()).<br><br>
 This function is the same as the C++ method
 OGRLayer::SetAttributeFilter().<br><br> handle to the layer on which attribute query will be executed. query in restricted SQL WHERE format, or NULL to clear the current query.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-l-set-feature"></a><div class="sp-lambda-list"><b>Function ogr-l-set-feature</b> (hlayer hfeat)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">OGRERR_NONE if the operation works, otherwise an appropriate error code.</div><div class="sph3">Details:</div><div class="indent">Rewrite an existing feature.<br><br>
 This function will write a feature to the layer, based on the feature
 id within the OGRFeature.<br><br>
 Use OGR_L_TestCapability(OLCRandomWrite) to establish if this layer
 supports random access writing via OGR_L_SetFeature().<br><br>
 This function is the same as the C++ method OGRLayer::SetFeature().<br><br> handle to the layer to write the feature. the feature to write.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-l-set-ignored-fields"></a><div class="sp-lambda-list"><b>Function ogr-l-set-ignored-fields</b> (hlayer papszfields)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">OGRERR_NONE if all field names have been resolved (even if the driver does not support this method)</div><div class="sph3">Details:</div><div class="indent">Set which fields can be omitted when retrieving features from the
 layer.<br><br>
 If the driver supports this functionality (testable using
 OLCIgnoreFields capability), it will not fetch the specified fields
 in subsequent calls to GetFeature() / GetNextFeature() and thus save
 some processing time and/or bandwidth.<br><br>
 Besides field names of the layers, the following special fields can
 be passed: &quot;OGR_GEOMETRY&quot; to ignore geometry and &quot;OGR_STYLE&quot; to
 ignore layer style.<br><br>
 By default, no fields are ignored.<br><br>
 This method is the same as the C++ method OGRLayer::SetIgnoredFields()<br><br> an array of field names terminated by NULL item. If NULL is passed, the ignored list is cleared.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-l-set-next-by-index"></a><div class="sp-lambda-list"><b>Function ogr-l-set-next-by-index</b> (hlayer nindex)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">OGRERR_NONE on success or an error code.</div><div class="sph3">Details:</div><div class="indent">Move read cursor to the nIndex'th feature in the current resultset.<br><br>
 This method allows positioning of a layer such that the
 GetNextFeature() call will read the requested feature, where nIndex
 is an absolute index into the current result set. So, setting it to 3
 would mean the next feature read with GetNextFeature() would have
 been the 4th feature to have been read if sequential reading took
 place from the beginning of the layer, including accounting for
 spatial and attribute filters.<br><br>
 Only in rare circumstances is SetNextByIndex() efficiently
 implemented. In all other cases the default implementation which
 calls ResetReading() and then calls GetNextFeature() nIndex times is
 used. To determine if fast seeking is available on the current layer
 use the TestCapability() method with a value of
 OLCFastSetNextByIndex.<br><br>
 This method is the same as the C++ method OGRLayer::SetNextByIndex()<br><br> handle to the layer the index indicating how many steps into the result set to seek.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-l-set-spatial-filter"></a><div class="sp-lambda-list"><b>Function ogr-l-set-spatial-filter</b> (hlayer hgeom)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Set a new spatial filter.<br><br>
 This function set the geometry to be used as a spatial filter when
 fetching features via the OGR_L_GetNextFeature() function. Only
 features that geometrically intersect the filter geometry will be
 returned.<br><br>
 Currently this test is may be inaccurately implemented, but it is
 guaranteed that all features who's envelope (as returned by
 OGR_G_GetEnvelope()) overlaps the envelope of the spatial filter will
 be returned. This can result in more shapes being returned that
 should strictly be the case.<br><br>
 This function makes an internal copy of the passed geometry. The
 passed geometry remains the responsibility of the caller, and may be
 safely destroyed.<br><br>
 For the time being the passed filter geometry should be in the same
 SRS as the layer (as returned by OGR_L_GetSpatialRef()). In the
 future this may be generalized.<br><br>
 This function is the same as the C++ method
 OGRLayer::SetSpatialFilter.<br><br> handle to the layer on which to set the spatial filter. handle to the geometry to use as a filtering
 region. NULL may be passed indicating that the current spatial filter should be cleared, but no new one instituted.</div></div></div><br><a name="cl-ogr__fun__ogr-l-set-spatial-filter-ex"></a><div class="sp-lambda-list"><b>Function ogr-l-set-spatial-filter-ex</b> (hlayer igeomfield hgeom)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Set a new spatial filter.<br><br>
 This function set the geometry to be used as a spatial filter when
 fetching features via the OGR_L_GetNextFeature() function. Only
 features that geometrically intersect the filter geometry will be
 returned.<br><br>
 Currently this test is may be inaccurately implemented, but it is
 guaranteed that all features who's envelope (as returned by
 OGR_G_GetEnvelope()) overlaps the envelope of the spatial filter will
 be returned. This can result in more shapes being returned that
 should strictly be the case.<br><br>
 This function makes an internal copy of the passed geometry. The
 passed geometry remains the responsibility of the caller, and may be
 safely destroyed.<br><br>
 For the time being the passed filter geometry should be in the same
 SRS as the geometry field definition it corresponds to (as returned
 by GetLayerDefn()-&gt;GetGeomFieldDefn(iGeomField)-&gt;GetSpatialRef()). In
 the future this may be generalized.<br><br>
 Note that only the last spatial filter set is applied, even if
 several successive calls are done with different iGeomField values.<br><br>
 This function is the same as the C++ method
 OGRLayer::SetSpatialFilter.<br><br> handle to the layer on which to set the spatial filter. index of the geometry field on which the spatial filter operates. handle to the geometry to use as a filtering
 region. NULL may be passed indicating that the current spatial filter should be cleared, but no new one instituted.<br><br> Since: GDAL 2.0</div></div></div><br><a name="cl-ogr__fun__ogr-l-set-spatial-filter-rect"></a><div class="sp-lambda-list"><b>Function ogr-l-set-spatial-filter-rect</b> (hlayer dfminx dfminy dfmaxx dfmaxy)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Set a new rectangular spatial filter.<br><br>
 This method set rectangle to be used as a spatial filter when
 fetching features via the OGR_L_GetNextFeature() method. Only
 features that geometrically intersect the given rectangle will be
 returned.<br><br>
 The x/y values should be in the same coordinate system as the layer
 as a whole (as returned by OGRLayer::GetSpatialRef()). Internally
 this method is normally implemented as creating a 5 vertex closed
 rectangular polygon and passing it to
 OGRLayer::SetSpatialFilter(). It exists as a convenience.<br><br>
 The only way to clear a spatial filter set with this method is to
 call OGRLayer::SetSpatialFilter(NULL).<br><br>
 This method is the same as the C++ method OGRLayer::SetSpatialFilterRect().<br><br> handle to the layer on which to set the spatial filter. the minimum X coordinate for the rectangular region. the minimum Y coordinate for the rectangular region. the maximum X coordinate for the rectangular region. the maximum Y coordinate for the rectangular region.</div></div></div><br><a name="cl-ogr__fun__ogr-l-set-spatial-filter-rect-ex"></a><div class="sp-lambda-list"><b>Function ogr-l-set-spatial-filter-rect-ex</b> (hlayer igeomfield dfminx dfminy dfmaxx dfmaxy)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Set a new rectangular spatial filter.<br><br>
 This method set rectangle to be used as a spatial filter when
 fetching features via the OGR_L_GetNextFeature() method. Only
 features that geometrically intersect the given rectangle will be
 returned.<br><br>
 The x/y values should be in the same coordinate system as as the
 geometry field definition it corresponds to (as returned by
 GetLayerDefn()-&gt;GetGeomFieldDefn(iGeomField)-&gt;GetSpatialRef()). Internally
 this method is normally implemented as creating a 5 vertex closed
 rectangular polygon and passing it to
 OGRLayer::SetSpatialFilter(). It exists as a convenience.<br><br>
 The only way to clear a spatial filter set with this method is to
 call OGRLayer::SetSpatialFilter(NULL).<br><br>
 This method is the same as the C++ method
 OGRLayer::SetSpatialFilterRect().<br><br> handle to the layer on which to set the spatial filter. index of the geometry field on which the spatial filter operates. the minimum X coordinate for the rectangular region. the minimum Y coordinate for the rectangular region. the maximum X coordinate for the rectangular region. the maximum Y coordinate for the rectangular region.<br><br> Since: GDAL 2.0</div></div></div><br><a name="cl-ogr__fun__ogr-l-start-transaction"></a><div class="sp-lambda-list"><b>Function ogr-l-start-transaction</b> (hlayer)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">OGRERR_NONE on success.</div><div class="sph3">Details:</div><div class="indent">For datasources which support transactions, StartTransaction creates
 a transaction.<br><br>
 If starting the transaction fails, will return
 OGRERR_FAILURE. Datasources which do not support transactions will
 always return OGRERR_NONE.<br><br>
 This function is the same as the C++ method OGRLayer::StartTransaction().<br><br> handle to the layer<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-l-sym-difference"></a><div class="sp-lambda-list"><b>Function ogr-l-sym-difference</b> (playerinput playermethod playerresult papszoptions pfnprogress pprogressarg)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</div><div class="sph3">Details:</div><div class="indent">Symmetrical difference of two layers.<br><br>
 The result layer contains features whose geometries represent areas
 that are in either in the input layer or in the method layer but not
 in both. The features in the result layer have attributes from both
 input and method layers. For features which represent areas that are
 only in the input or in the method layer the respective attributes
 have undefined values. The schema of the result layer can be set by
 the user or, if it is empty, is initialized to contain all fields in
 the input and method layers.<br><br>
 Note: If the schema of the result is set by user and contains fields
 that have the same name as a field in input and in method layer, then
 the attribute in the result feature will get the value from the
 feature of the method layer (even if it is undefined).<br><br>
 For best performance use the minimum amount of features in the method
 layer and copy it into a memory layer.<br><br>
 This method relies on GEOS support. Do not use unless the GEOS
 support is compiled in.<br><br>
The recognized list of options is :
 SKIP_FAILURES=YES/NO. Set it to YES to go on, even when a feature could not be inserted.
 PROMOTE_TO_MULTI=YES/NO. Set it to YES to convert Polygons into MultiPolygons, or LineStrings to MultiLineStrings.
 INPUT_PREFIX=string. Set a prefix for the field names that will be created from the fields of the input layer.
 METHOD_PREFIX=string. Set a prefix for the field names that will be created from the fields of the method layer.<br><br>
 This function is the same as the C++ method
 OGRLayer::SymDifference().<br><br> the input layer. Should not be NULL. the method layer. Should not be NULL. the layer where the features resulting from
 the operation are inserted. Should not be NULL. See above the note about the schema. NULL terminated list of options (may be NULL). a GDALProgressFunc() compatible callback function for reporting progress or NULL. argument to be passed to pfnProgress. May be NULL.<br><br> <br><br> Since: OGR 1.10</div></div></div><br><a name="cl-ogr__fun__ogr-l-test-capability"></a><div class="sp-lambda-list"><b>Function ogr-l-test-capability</b> (hlayer pszcap)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">TRUE if the layer has the requested capability, or FALSE
 otherwise. OGRLayers will return FALSE for any unrecognised capabilities.</div><div class="sph3">Details:</div><div class="indent">Test if this layer supported the named capability.<br><br>
The capability codes that can be tested are represented as strings, but #defined constants exists to ensure correct spelling. Specific layer types may implement class specific capabilities, but this can't generally be discovered by the caller.<br><br>
OLCRandomRead / &quot;RandomRead&quot;: TRUE if the GetFeature() method is implemented in an optimized way for this layer, as opposed to the default implementation using ResetReading() and GetNextFeature() to find the requested feature id.<br><br>
OLCSequentialWrite / &quot;SequentialWrite&quot;: TRUE if the CreateFeature() method works for this layer. Note this means that this particular layer is writable. The same OGRLayer class may returned FALSE for other layer instances that are effectively read-only.<br><br>
OLCRandomWrite / &quot;RandomWrite&quot;: TRUE if the SetFeature() method is operational on this layer. Note this means that this particular layer is writable. The same OGRLayer class may returned FALSE for other layer instances that are effectively read-only.<br><br>
OLCFastSpatialFilter / &quot;FastSpatialFilter&quot;: TRUE if this layer implements spatial filtering efficiently. Layers that effectively read all features, and test them with the OGRFeature intersection methods should return FALSE. This can be used as a clue by the application whether it should build and maintain its own spatial index for features in this layer.<br><br>
OLCFastFeatureCount / &quot;FastFeatureCount&quot;: TRUE if this layer can return a feature count (via OGR_L_GetFeatureCount()) efficiently ... ie. without counting the features. In some cases this will return TRUE until a spatial filter is installed after which it will return FALSE.<br><br>
OLCFastGetExtent / &quot;FastGetExtent&quot;: TRUE if this layer can return its data extent (via OGR_L_GetExtent()) efficiently ... ie. without scanning all the features. In some cases this will return TRUE until a spatial filter is installed after which it will return FALSE.<br><br>
OLCFastSetNextByIndex / &quot;FastSetNextByIndex&quot;: TRUE if this layer can perform the SetNextByIndex() call efficiently, otherwise FALSE.<br><br>
OLCCreateField / &quot;CreateField&quot;: TRUE if this layer can create new fields on the current layer using CreateField(), otherwise FALSE.<br><br>
OLCCreateGeomField / &quot;CreateGeomField&quot;: (GDAL &gt;= 2.0) TRUE if this layer can create new geometry fields on the current layer using CreateGeomField(), otherwise FALSE.<br><br>
OLCDeleteField / &quot;DeleteField&quot;: TRUE if this layer can delete existing fields on the current layer using DeleteField(), otherwise FALSE.<br><br>
OLCReorderFields / &quot;ReorderFields&quot;: TRUE if this layer can reorder existing fields on the current layer using ReorderField() or ReorderFields(), otherwise FALSE.<br><br>
OLCAlterFieldDefn / &quot;AlterFieldDefn&quot;: TRUE if this layer can alter the definition of an existing field on the current layer using AlterFieldDefn(), otherwise FALSE.<br><br>
OLCDeleteFeature / &quot;DeleteFeature&quot;: TRUE if the DeleteFeature() method is supported on this layer, otherwise FALSE.<br><br>
OLCStringsAsUTF8 / &quot;StringsAsUTF8&quot;: TRUE if values of OFTString fields are assured to be in UTF-8 format. If FALSE the encoding of fields is uncertain, though it might still be UTF-8.<br><br>
OLCTransactions / &quot;Transactions&quot;: TRUE if the StartTransaction(), CommitTransaction() and RollbackTransaction() methods work in a meaningful way, otherwise FALSE.<br><br>
This function is the same as the C++ method OGRLayer::TestCapability().<br><br>handle to the layer to get the capability from.the name of the capability to test.<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr-l-union"></a><div class="sp-lambda-list"><b>Function ogr-l-union</b> (playerinput playermethod playerresult papszoptions pfnprogress pprogressarg)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</div><div class="sph3">Details:</div><div class="indent">Union of two layers.<br><br>
 The result layer contains features whose geometries represent areas
 that are in either in the input layer or in the method layer. The
 features in the result layer have attributes from both input and
 method layers. For features which represent areas that are only in
 the input or in the method layer the respective attributes have
 undefined values. The schema of the result layer can be set by the
 user or, if it is empty, is initialized to contain all fields in the
 input and method layers.<br><br>
 Note: If the schema of the result is set by user and contains fields
 that have the same name as a field in input and in method layer, then
 the attribute in the result feature will get the value from the
 feature of the method layer (even if it is undefined).<br><br>
 For best performance use the minimum amount of features in the method
 layer and copy it into a memory layer.<br><br>
 This method relies on GEOS support. Do not use unless the GEOS
 support is compiled in.<br><br>
The recognized list of options is :
 SKIP_FAILURES=YES/NO. Set it to YES to go on, even when a feature could not be inserted.
 PROMOTE_TO_MULTI=YES/NO. Set it to YES to convert Polygons into MultiPolygons, or LineStrings to MultiLineStrings.
 INPUT_PREFIX=string. Set a prefix for the field names that will be created from the fields of the input layer.
 METHOD_PREFIX=string. Set a prefix for the field names that will be created from the fields of the method layer.<br><br>
 This function is the same as the C++ method OGRLayer::Union().<br><br> the input layer. Should not be NULL. the method layer. Should not be NULL. the layer where the features resulting from
 the operation are inserted. Should not be NULL. See above the note about the schema. NULL terminated list of options (may be NULL). a GDALProgressFunc() compatible callback function for reporting progress or NULL. argument to be passed to pfnProgress. May be NULL.<br><br> <br><br> Since: OGR 1.10</div></div></div><br><a name="cl-ogr__fun__ogr-l-update"></a><div class="sp-lambda-list"><b>Function ogr-l-update</b> (playerinput playermethod playerresult papszoptions pfnprogress pprogressarg)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</div><div class="sph3">Details:</div><div class="indent">Update this layer with features from the update layer.<br><br>
 The result layer contains features whose geometries represent areas
 that are either in the input layer or in the method layer. The
 features in the result layer have areas of the features of the method
 layer or those ares of the features of the input layer that are not
 covered by the method layer. The features of the result layer get
 their attributes from the input layer. The schema of the result layer
 can be set by the user or, if it is empty, is initialized to contain
 all fields in the input layer.<br><br>
 Note: If the schema of the result is set by user and contains fields
 that have the same name as a field in the method layer, then the
 attribute in the result feature the originates from the method layer
 will get the value from the feature of the method layer.<br><br>
 For best performance use the minimum amount of features in the method
 layer and copy it into a memory layer.<br><br>
 This method relies on GEOS support. Do not use unless the GEOS
 support is compiled in.<br><br>
The recognized list of options is :
 SKIP_FAILURES=YES/NO. Set it to YES to go on, even when a feature could not be inserted.
 PROMOTE_TO_MULTI=YES/NO. Set it to YES to convert Polygons into MultiPolygons, or LineStrings to MultiLineStrings.
 INPUT_PREFIX=string. Set a prefix for the field names that will be created from the fields of the input layer.
 METHOD_PREFIX=string. Set a prefix for the field names that will be created from the fields of the method layer.<br><br>
 This function is the same as the C++ method OGRLayer::Update().<br><br> the input layer. Should not be NULL. the method layer. Should not be NULL. the layer where the features resulting from
 the operation are inserted. Should not be NULL. See above the note about the schema. NULL terminated list of options (may be NULL). a GDALProgressFunc() compatible callback function for reporting progress or NULL. argument to be passed to pfnProgress. May be NULL.<br><br> <br><br> Since: OGR 1.10</div></div></div><br><a name="cl-ogr__fun__ogr-open"></a><div class="sp-lambda-list"><b>Function ogr-open</b> (psz-name p-update path-driver-list)</div><div class="sp-definition"><div class="sp-definition-body"><p style="color: red; font-weight: bold">
	  No documentation string.  Possibly unimplemented or incomplete.
	</p></div></div><br><a name="cl-ogr__fun__ogr-register-all"></a><div class="sp-lambda-list"><b>Function ogr-register-all</b> ()</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Register all drivers.</div></div></div><br><a name="cl-ogr__fun__ogr-register-driver"></a><div class="sp-lambda-list"><b>Function ogr-register-driver</b> (hdriver)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Add a driver to the list of registered drivers.<br><br>
 If the passed driver is already registered (based on handle
 comparison) then the driver isn't registered. New drivers are added
 at the end of the list of registered drivers.<br><br>
 This function is the same as the C++ method
 OGRSFDriverRegistrar::RegisterDriver().<br><br> handle to the driver to add.</div></div></div><br><a name="cl-ogr__fun__ogr-release-data-source"></a><div class="sp-lambda-list"><b>Function ogr-release-data-source</b> (hds)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Returns:</div><div class="indent">:NONE on success or an error code.</div><div class="sph3">Details:</div><div class="indent">Drop a reference to this datasource, and if the reference count
 drops to zero close (destroy) the datasource.<br><br>
 Internally this actually calls the
 OGRSFDriverRegistrar::ReleaseDataSource() method. This method is
 essentially a convenient alias.<br><br>
 This method is the same as the C++ method OGRDataSource::Release()<br><br> handle to the data source to release<br><br> </div></div></div><br><a name="cl-ogr__fun__ogr_fd_setstyleignored"></a><div class="sp-lambda-list"><b>Function ogr_fd_setstyleignored</b> (hdefn bignore)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Set whether the style can be omitted when fetching features.<br><br>
 This function is the same as the C++ method
 OGRFeatureDefn::SetStyleIgnored().<br><br> handle to the feature definition on witch OGRFeature are based on. ignore state</div></div></div><br><a name="cl-ogr__fun__open-data-source"></a><div class="sp-lambda-list"><b>Function open-data-source</b> (name &amp;optional (update 0) (drivers (null-pointer)))</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">Returns DATA-SOURCE instance in case of success, NIL otherwise.</div></div></div><br><a name="cl-ogr__fun__wkb-flatten"></a><div class="sp-lambda-list"><b>Function wkb-flatten</b> (x)</div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Details:</div><div class="indent">The wkb-flatten function is used above to convert the type for a
:wkbPoint25D (a point with a z coordinate) into the base 2D geometry
type code (:wkbPoint). For each 2D geometry type there is a
corresponding 2.5D type code. The 2D and 2.5D geometry cases are
handled by the same C++ class, so our code will handle 2D or 3D casesproperly.</div></div></div><br><h3>Other classes in cl-ogr</h3><a name="cl-ogr__class__data-source"></a><div class="sp-lambda-list"><b>Class data-source</b></div><div class="sp-definition"><div class="sp-definition-body"><div class="sph3">Superclasses:</div><div class="indent"><tt style="color: #777777">cl-ogr::ogr-class</tt>, <tt style="color: #777777">common-lisp:standard-object</tt>, <tt style="color: #777777">sb-pcl::slot-object</tt>, <tt style="color: #777777">common-lisp:t</tt></div><div class="sph3">Documented Subclasses:</div><div class="indent">
	      None
	    </div><div class="sph3">Details:</div><div class="indent">This class represents a data source.<br><br>
  A data source potentially consists of many layers (OGRLayer). A data
  source normally consists of one, or a related set of files, though
  the name doesn't have to be a real item in the file system.<br><br>
  When an OGRDataSource is destroyed, all it's associated OGRLayers  objects are also destroyed.</div></div></div><br><h3><a name="index"></a>Index of exported symbols</h3><table cellspacing="0" cellpadding="0"><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__data-source"><tt>data-source</tt></a>, function <span style="color: red">
	(undocumented)
      </span></td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__class__data-source"><tt>data-source</tt></a>, class</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__delete-layer"><tt>delete-layer</tt></a>, function <span style="color: red">
	(undocumented)
      </span></td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__get-layer"><tt>get-layer</tt></a>, function <span style="color: red">
	(undocumented)
      </span></td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__get-layer-by-name"><tt>get-layer-by-name</tt></a>, function <span style="color: red">
	(undocumented)
      </span></td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__get-layer-count"><tt>get-layer-count</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__get-name"><tt>get-name</tt></a>, function <span style="color: red">
	(undocumented)
      </span></td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-build-polygon-from-edges"><tt>ogr-build-polygon-from-edges</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-deregister-driver"><tt>ogr-deregister-driver</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-ds-copy-layer"><tt>ogr-ds-copy-layer</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-ds-create-layer"><tt>ogr-ds-create-layer</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-ds-delete-layer"><tt>ogr-ds-delete-layer</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-ds-destroy"><tt>ogr-ds-destroy</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-ds-execute-sql"><tt>ogr-ds-execute-sql</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-ds-get-driver"><tt>ogr-ds-get-driver</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-ds-get-layer"><tt>ogr-ds-get-layer</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-ds-get-layer-by-name"><tt>ogr-ds-get-layer-by-name</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-ds-get-layer-count"><tt>ogr-ds-get-layer-count</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-ds-get-name"><tt>ogr-ds-get-name</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-ds-release-result-set"><tt>ogr-ds-release-result-set</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-ds-sync-to-disk"><tt>ogr-ds-sync-to-disk</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-ds-test-capability"><tt>ogr-ds-test-capability</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-f-clone"><tt>ogr-f-clone</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-f-create"><tt>ogr-f-create</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-f-destroy"><tt>ogr-f-destroy</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-f-dump-readable"><tt>ogr-f-dump-readable</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-f-equal"><tt>ogr-f-equal</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-f-get-defn-ref"><tt>ogr-f-get-defn-ref</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-f-get-field-as-binary"><tt>ogr-f-get-field-as-binary</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-f-get-field-as-date-time"><tt>ogr-f-get-field-as-date-time</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-f-get-field-as-double"><tt>ogr-f-get-field-as-double</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-f-get-field-as-double-list"><tt>ogr-f-get-field-as-double-list</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-f-get-field-as-integer"><tt>ogr-f-get-field-as-integer</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-f-get-field-as-integer-list"><tt>ogr-f-get-field-as-integer-list</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-f-get-field-as-string"><tt>ogr-f-get-field-as-string</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-f-get-field-as-string-list"><tt>ogr-f-get-field-as-string-list</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-f-get-field-count"><tt>ogr-f-get-field-count</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-f-get-field-defn-ref"><tt>ogr-f-get-field-defn-ref</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-f-get-field-index"><tt>ogr-f-get-field-index</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-f-get-geom-field-count"><tt>ogr-f-get-geom-field-count</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-f-get-geom-field-defn-ref"><tt>ogr-f-get-geom-field-defn-ref</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-f-get-geom-field-index"><tt>ogr-f-get-geom-field-index</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-f-get-geom-field-ref"><tt>ogr-f-get-geom-field-ref</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-f-get-geometry-ref"><tt>ogr-f-get-geometry-ref</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-f-get-raw-field-ref"><tt>ogr-f-get-raw-field-ref</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-f-get-style-string"><tt>ogr-f-get-style-string</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-f-is-field-set"><tt>ogr-f-is-field-set</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-f-set-fid"><tt>ogr-f-set-fid</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-f-set-field-binary"><tt>ogr-f-set-field-binary</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-f-set-field-date-time"><tt>ogr-f-set-field-date-time</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-f-set-field-double"><tt>ogr-f-set-field-double</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-f-set-field-double-list"><tt>ogr-f-set-field-double-list</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-f-set-field-integer"><tt>ogr-f-set-field-integer</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-f-set-field-integer-list"><tt>ogr-f-set-field-integer-list</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-f-set-field-raw"><tt>ogr-f-set-field-raw</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-f-set-field-string"><tt>ogr-f-set-field-string</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-f-set-field-string-list"><tt>ogr-f-set-field-string-list</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-f-set-from"><tt>ogr-f-set-from</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-f-set-from-with-map"><tt>ogr-f-set-from-with-map</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-f-set-geom-field"><tt>ogr-f-set-geom-field</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-f-set-geom-field-directly"><tt>ogr-f-set-geom-field-directly</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-f-set-geometry"><tt>ogr-f-set-geometry</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-f-set-geometry-directly"><tt>ogr-f-set-geometry-directly</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-f-set-style-string"><tt>ogr-f-set-style-string</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-f-set-style-string-directly"><tt>ogr-f-set-style-string-directly</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-f-steal-geometry"><tt>ogr-f-steal-geometry</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-f-unset-field"><tt>ogr-f-unset-field</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-fd-add-field-defn"><tt>ogr-fd-add-field-defn</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-fd-add-geom-field-defn"><tt>ogr-fd-add-geom-field-defn</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-fd-create"><tt>ogr-fd-create</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-fd-delete-field-defn"><tt>ogr-fd-delete-field-defn</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-fd-delete-geom-field-defn"><tt>ogr-fd-delete-geom-field-defn</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-fd-dereference"><tt>ogr-fd-dereference</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-fd-destroy"><tt>ogr-fd-destroy</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-fd-get-field-count"><tt>ogr-fd-get-field-count</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-fd-get-field-defn"><tt>ogr-fd-get-field-defn</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-fd-get-field-index"><tt>ogr-fd-get-field-index</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-fd-get-geom-field-count"><tt>ogr-fd-get-geom-field-count</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-fd-get-geom-field-defn"><tt>ogr-fd-get-geom-field-defn</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-fd-get-geom-field-index"><tt>ogr-fd-get-geom-field-index</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-fd-get-geom-type"><tt>ogr-fd-get-geom-type</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-fd-get-name"><tt>ogr-fd-get-name</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-fd-get-reference-count"><tt>ogr-fd-get-reference-count</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-fd-is-geometry-ignored"><tt>ogr-fd-is-geometry-ignored</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-fd-is-same"><tt>ogr-fd-is-same</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-fd-is-style-ignored"><tt>ogr-fd-is-style-ignored</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-fd-reference"><tt>ogr-fd-reference</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-fd-release"><tt>ogr-fd-release</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-fd-set-geom-type"><tt>ogr-fd-set-geom-type</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-fd-set-geometry-ignored"><tt>ogr-fd-set-geometry-ignored</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-fld-create"><tt>ogr-fld-create</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-fld-destroy"><tt>ogr-fld-destroy</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-fld-get-justify"><tt>ogr-fld-get-justify</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-fld-get-name-ref"><tt>ogr-fld-get-name-ref</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-fld-get-precision"><tt>ogr-fld-get-precision</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-fld-get-type"><tt>ogr-fld-get-type</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-fld-get-width"><tt>ogr-fld-get-width</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-fld-is-ignored"><tt>ogr-fld-is-ignored</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-fld-set"><tt>ogr-fld-set</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-fld-set-ignored"><tt>ogr-fld-set-ignored</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-fld-set-justify"><tt>ogr-fld-set-justify</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-fld-set-name"><tt>ogr-fld-set-name</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-fld-set-precision"><tt>ogr-fld-set-precision</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-fld-set-type"><tt>ogr-fld-set-type</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-fld-set-width"><tt>ogr-fld-set-width</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-add-geometry"><tt>ogr-g-add-geometry</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-add-geometry-directly"><tt>ogr-g-add-geometry-directly</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-add-point"><tt>ogr-g-add-point</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-add-point-2d"><tt>ogr-g-add-point-2d</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-approximate-arc-angles"><tt>ogr-g-approximate-arc-angles</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-area"><tt>ogr-g-area</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-assign-spatial-reference"><tt>ogr-g-assign-spatial-reference</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-boundary"><tt>ogr-g-boundary</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-buffer"><tt>ogr-g-buffer</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-centroid"><tt>ogr-g-centroid</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-close-rings"><tt>ogr-g-close-rings</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-contains"><tt>ogr-g-contains</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-convex-hull"><tt>ogr-g-convex-hull</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-create-from-gml"><tt>ogr-g-create-from-gml</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-create-from-wkb"><tt>ogr-g-create-from-wkb</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-create-from-wkt"><tt>ogr-g-create-from-wkt</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-create-geometry"><tt>ogr-g-create-geometry</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-crosses"><tt>ogr-g-crosses</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-difference"><tt>ogr-g-difference</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-disjoint"><tt>ogr-g-disjoint</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-distance"><tt>ogr-g-distance</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-empty"><tt>ogr-g-empty</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-equals"><tt>ogr-g-equals</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-export-to-gml"><tt>ogr-g-export-to-gml</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-export-to-gml-ex"><tt>ogr-g-export-to-gml-ex</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-export-to-json"><tt>ogr-g-export-to-json</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-export-to-json-ex"><tt>ogr-g-export-to-json-ex</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-export-to-kml"><tt>ogr-g-export-to-kml</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-flatten-to-2d"><tt>ogr-g-flatten-to-2d</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-force-to-polygon"><tt>ogr-g-force-to-polygon</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-get-geometry-count"><tt>ogr-g-get-geometry-count</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-get-geometry-name"><tt>ogr-g-get-geometry-name</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-get-geometry-ref"><tt>ogr-g-get-geometry-ref</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-get-geometry-type"><tt>ogr-g-get-geometry-type</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-get-point"><tt>ogr-g-get-point</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-get-point-count"><tt>ogr-g-get-point-count</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-get-points"><tt>ogr-g-get-points</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-get-spatial-reference"><tt>ogr-g-get-spatial-reference</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-getx"><tt>ogr-g-getx</tt></a>, function <span style="color: red">
	(undocumented)
      </span></td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-gety"><tt>ogr-g-gety</tt></a>, function <span style="color: red">
	(undocumented)
      </span></td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-getz"><tt>ogr-g-getz</tt></a>, function <span style="color: red">
	(undocumented)
      </span></td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-intersection"><tt>ogr-g-intersection</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-intersects"><tt>ogr-g-intersects</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-is-empty"><tt>ogr-g-is-empty</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-is-ring"><tt>ogr-g-is-ring</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-is-simple"><tt>ogr-g-is-simple</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-is-valid"><tt>ogr-g-is-valid</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-length"><tt>ogr-g-length</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-overlaps"><tt>ogr-g-overlaps</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-point-on-surface"><tt>ogr-g-point-on-surface</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-polygonize"><tt>ogr-g-polygonize</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-remove-geometry"><tt>ogr-g-remove-geometry</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-segmentize"><tt>ogr-g-segmentize</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-set-point"><tt>ogr-g-set-point</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-set-point-2d"><tt>ogr-g-set-point-2d</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-simplify"><tt>ogr-g-simplify</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-simplify-preserve-topology"><tt>ogr-g-simplify-preserve-topology</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-sym-difference"><tt>ogr-g-sym-difference</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-touches"><tt>ogr-g-touches</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-transform"><tt>ogr-g-transform</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-transform-to"><tt>ogr-g-transform-to</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-union"><tt>ogr-g-union</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-union-cascaded"><tt>ogr-g-union-cascaded</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-g-within"><tt>ogr-g-within</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-get-driver"><tt>ogr-get-driver</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-get-driver-by-name"><tt>ogr-get-driver-by-name</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-get-driver-count"><tt>ogr-get-driver-count</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-get-field-type-name"><tt>ogr-get-field-type-name</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-get-open-ds"><tt>ogr-get-open-ds</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-get-open-ds-count"><tt>ogr-get-open-ds-count</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-gfld-create"><tt>ogr-gfld-create</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-gfld-destroy"><tt>ogr-gfld-destroy</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-gfld-get-name-ref"><tt>ogr-gfld-get-name-ref</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-gfld-get-spatial-ref"><tt>ogr-gfld-get-spatial-ref</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-gfld-get-type"><tt>ogr-gfld-get-type</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-gfld-is-ignored"><tt>ogr-gfld-is-ignored</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-gfld-set-ignored"><tt>ogr-gfld-set-ignored</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-gfld-set-name"><tt>ogr-gfld-set-name</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-gfld-set-spatial-ref"><tt>ogr-gfld-set-spatial-ref</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-gfld-set-type"><tt>ogr-gfld-set-type</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-l-alter-field-defn"><tt>ogr-l-alter-field-defn</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-l-clip"><tt>ogr-l-clip</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-l-commit-transaction"><tt>ogr-l-commit-transaction</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-l-create-feature"><tt>ogr-l-create-feature</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-l-create-field"><tt>ogr-l-create-field</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-l-create-geom-field"><tt>ogr-l-create-geom-field</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-l-delete-feature"><tt>ogr-l-delete-feature</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-l-delete-field"><tt>ogr-l-delete-field</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-l-erase"><tt>ogr-l-erase</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-l-get-extent"><tt>ogr-l-get-extent</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-l-get-extent-ex"><tt>ogr-l-get-extent-ex</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-l-get-feature"><tt>ogr-l-get-feature</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-l-get-feature-count"><tt>ogr-l-get-feature-count</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-l-get-geom-type"><tt>ogr-l-get-geom-type</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-l-get-layer-defn"><tt>ogr-l-get-layer-defn</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-l-get-name"><tt>ogr-l-get-name</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-l-get-next-feature"><tt>ogr-l-get-next-feature</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-l-get-spatial-filter"><tt>ogr-l-get-spatial-filter</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-l-get-spatial-ref"><tt>ogr-l-get-spatial-ref</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-l-identity"><tt>ogr-l-identity</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-l-intersection"><tt>ogr-l-intersection</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-l-reorder-field"><tt>ogr-l-reorder-field</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-l-reorder-fields"><tt>ogr-l-reorder-fields</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-l-reset-reading"><tt>ogr-l-reset-reading</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-l-rollback-transaction"><tt>ogr-l-rollback-transaction</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-l-set-attribute-filter"><tt>ogr-l-set-attribute-filter</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-l-set-feature"><tt>ogr-l-set-feature</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-l-set-ignored-fields"><tt>ogr-l-set-ignored-fields</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-l-set-next-by-index"><tt>ogr-l-set-next-by-index</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-l-set-spatial-filter"><tt>ogr-l-set-spatial-filter</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-l-set-spatial-filter-ex"><tt>ogr-l-set-spatial-filter-ex</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-l-set-spatial-filter-rect"><tt>ogr-l-set-spatial-filter-rect</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-l-set-spatial-filter-rect-ex"><tt>ogr-l-set-spatial-filter-rect-ex</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-l-start-transaction"><tt>ogr-l-start-transaction</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-l-sym-difference"><tt>ogr-l-sym-difference</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-l-test-capability"><tt>ogr-l-test-capability</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-l-union"><tt>ogr-l-union</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-l-update"><tt>ogr-l-update</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-open"><tt>ogr-open</tt></a>, function <span style="color: red">
	(undocumented)
      </span></td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-register-all"><tt>ogr-register-all</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-register-driver"><tt>ogr-register-driver</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr-release-data-source"><tt>ogr-release-data-source</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__ogr_fd_setstyleignored"><tt>ogr_fd_setstyleignored</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__open-data-source"><tt>open-data-source</tt></a>, function</td></tr><tr><td valign="top" align="right" nowrap><span class="nonlink"><tt><span style="color: #777777">cl-ogr:</span></tt></span></td><td valign="top"><a href="#cl-ogr__fun__wkb-flatten"><tt>wkb-flatten</tt></a>, function</td></tr></table><div style="height: 10em"></div></div></body></html>